<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<script name="Create L2VSN">
    <abortOnError>true</abortOnError>
    <auditLogEnabled></auditLogEnabled>
    <category>,Config,</category>
    <comments>Create L2VSN across any of VSP,XOS,ERS - v2.3</comments>
    <content>'''
This script is provided free of charge by Extreme. We hope such scripts are
helpful when used in conjunction with Extreme products and technology and can
be used as examples to modify and adapt for your ultimate requirements.
Extreme will not provide any official support for these scripts. If you do
have any questions or queries about any of these scripts you may post on
Extreme's community website "The Hub" (https://community.extremenetworks.com/)
under the scripting category.

ANY SCRIPTS PROVIDED BY EXTREME ARE HEREBY PROVIDED "AS IS", WITHOUT WARRANTY
OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL EXTREME OR ITS THIRD PARTY LICENSORS BE LIABLE FOR ANY CLAIM,
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE USE OR DISTRIBUTION OF SUCH
SCRIPTS.
'''

##########################################################
# XMC Script: Create L2VSN (for device context menu)     #
# Written by Ludovico Stevens, CSE Extreme Networks      #
##########################################################
# Create a L2VSN across any of VOSS, EXOS, BOSS
# Written by Ludovico Stevens, CSE Extreme Networks

__version__ = '2.3'

# 1.5 - Changed CLI dict 'get_isid_uni_data' so that it can work on VSP8600 also (no CLI grep)
#     - Creating a service with no ports and no vlan was giving an error about tagging mode
#     - Was failing if ERS switch was not configured with vlan configcontrol automatic
#     - Updated libraries
#     - If the XOS already had a dynamic VLAN script was failing to convert that VLAN to static
#     - XOS has changed some CLI commands; modifications to be able to specify 2 or more syntaxes
#     - If input MLT ids provided would try and flex-uni enable all MLTs on switch
# 1.6 - Updated with latest functions for use on universal hardware
# 1.7 - Added Universal Platform Fabric/Switch Engine in FamilyChildren (Dda)
# 1.8 - Improved VOSS logic to detect if selected ports are using Switched-UNI or CVLAN-UNI
#       but script only works if all ports (MLTs) selected are consistent; cannot currently
#       have some ports (MLTs) using CVLAN UNI and others using Switch-UNI
# 1.9 - Create I-SID now will work even if y/n confirmation prompt
# 2.0 - Updated all function libraries
#     - For VOSS implemented this logic:
        # Input Ports | DVR Leaf | Auto-Sense | Flex-uni   | Type to create
        #    yes      |   yes    | don't care | don't care | =&gt; create Switched-UNI
        #    yes      |   no     |    yes     | don't care | =&gt; create CVLAN-UNI
        #    yes      |   no     |    no      |    yes     | =&gt; create Switched-UNI
        #    yes      |   no     |    no      |    no      | =&gt; create CVLAN-UNI
        #    no       |   yes    |    no      |    no      | =&gt; create Switched-UNI
        #    no       |   no     |    no      |    no      | =&gt; create CVLAN-UNI
#
#     - Script can now configure both flex-uni and cvlan uni ports in the same run on VOSS
#     - Auto-sense is now checked, and disabled, before applying VLAN/binding on port
#     - The service name (VLAN name) is now also assigned to the I-SID name on VOSS
#     - After VSN creation, script now triggers device rediscovery and config reload via XIQ-SE
#       api (latter requires XIQ-SE version 23.2 or later).
# 2.1 - Fixed issue where creating a Switched-UNI on an auto-sense enabled port was failing because
#       when you disable auto-sense it has the effect of disabling flex-uni on the port
# 2.2 - Interim fix by Didier to allow subports in generatePortRange function
# 2.3 - Updated port processing functions to support channelized ports (slot/port/chan)

#
# XMC Metadata
#
'''
#@MetaDataStart
#@DetailDescriptionStart
######################################################################################
# 
# This script provisions a L2VSN between any Fabric Connect or Fabric Attach switch
# It works across all of VOSS VSPs (including in DVR Leaf mode), BOSS ERS and EXOS
#
# An I-SID must be provided.
#
# A service name can optionally be entered; if provided this will be assigned as VLAN
# name on CVLAN UNIs and will also set the I-SID name on VOSS.
#
# The VLAN-id must normally be provided as well, either at the global level or at the
# device level (when a value is provided at both global and device level, the device
# level value will be used). The exception is when creating an untagged Switched-UNI
# service, in which case no VLAN-id value is required and any value provided will be
# ignored.
#
# The Port list is optional. If provided, the service will be terminated on the ports.
# Port syntax follows the same syntax you would use on the switch; comma separated
# lists of ports or ranges are allowed; range syntaxes are 1/1-1/5 on a VSP, 1/1-5 on
# an ERS and 1:1-5 or 1:* on an XOS. Port ranges spanning slots (e.g. 1/1-2/24 or
# 1:1-2:24) are currently not supported.
# The MLT id list is also optional. This will only work on VSPs and the script will
# expect to find the MLTs already created on the switch (i.e. this script will not
# create the MLTs, just configure a L2VSN end-point on them) and to already have the 
# correct/requested tagging mode.
# If no Port list or MLT list is provided, the service will be created on the switch,
# globally but on no interfaces (this can be required when configuring a L2VSN on an
# SMLT-BEB pair, where the end-point is single attached to only one of the VSPs
# SMLT-BEBs; the other SMLT-BEB will need to have the same service termination or it
# will not work properly)
#
# If the device is a VSP which, the logic for creating either a CVLAN-UNI or a
# Switched-UNI is the following:
#
#    DVR Leaf | Auto-Sense | Flex-uni   | Type to create
#      yes    | don't care | don't care | =&gt; create Switched-UNI
#      no     |    yes     | don't care | =&gt; create CVLAN-UNI
#      no     |    no      |    yes     | =&gt; create Switched-UNI
#      no     |    no      |    no      | =&gt; create CVLAN-UNI
#
# If instead the device is an ERS or an XOS or an older VSP (not capable of supporting
# Flex-uni), then this script will provision a CVLAN-uni based service.
#
#######################################################################################
#@DetailDescriptionEnd

#@SectionStart (description = "Service Definition to create")
#    @VariableFieldLabel (
#        description = "SERVICE Id &amp;lt;100 - 15999999&amp;gt;",
#        type = string,
#        required = yes,
#        name = "userInput_isid",
#    )
#    @VariableFieldLabel (
#        description = "Service Name &amp;#40;VLAN Name&amp;#41;",
#        type = string,
#        required = no,
#        name = "userInput_vlanName",
#    )
#    @VariableFieldLabel (
#        description = "VLAN-id&amp;#44; can be overridden below at device level",
#        type = string,
#        required = no,
#        name = "userInput_vlanGlobal",
#    )
#    @VariableFieldLabel (
#        description = "Port list&amp;#44; can be overridden below at device level",
#        type = string,
#        required = no,
#        name = "userInput_portsGlobal",
#    )
#    @VariableFieldLabel (
#        description = "MLT id list &amp;#40;VSP only&amp;#41;&amp;#44; can be overridden below at device level",
#        type = string,
#        required = no,
#        name = "userInput_mltsGlobal",
#    )
#    @VariableFieldLabel (
#        description = "Tagging mode&amp;#44; can be overridden below at device level",
#        type = string,
#        required = no,
#        validValues = [tag,untag],
#        name = "userInput_tagGlobal",
#        value = "tag"
#    )
#@SectionEnd

#@SectionStart (description = "Device level Port and VLAN assignment to overrides above global values")
#    @VariableFieldLabel (
#        description = "Port&amp;#40;s&amp;#41;",
#        type = string,
#        required = no,
#        name = "userInput_ports",
#        scope = device
#    )
#    @VariableFieldLabel (
#        description = "MLT id&amp;#40;s&amp;#41;",
#        type = string,
#        required = no,
#        name = "userInput_mlts",
#        scope = device
#    )
#    @VariableFieldLabel (
#        description = "VLAN-id",
#        type = string,
#        required = no,
#        name = "userInput_vlan",
#        scope = device
#    )
#    @VariableFieldLabel (
#        description = "Tagging",
#        type = string,
#        required = no,
#        validValues = [tag,untag],
#        name = "userInput_tag",
#        scope = device
#    )
#@SectionEnd

#@SectionStart (description = "Sanity / Debug")
#    @VariableFieldLabel (
#        description = "Sanity: enable if you do not trust this script and wish to first see what it does. In sanity mode config commands are not executed",
#        type = string,
#        required = no,
#        validValues = [Enable, Disable],
#        name = "userInput_sanity",
#    )
#    @VariableFieldLabel (
#        description = "Debug: enable if you need to report a problem to the script author",
#        type = string,
#        required = no,
#        validValues = [Enable, Disable],
#        name = "userInput_debug",
#    )
#@SectionEnd
#@MetaDataEnd
'''



##########################################################
# Ludo Standard library; Version 4.02                    #
# Written by Ludovico Stevens, TME Extreme Networks      #
##########################################################
Debug = False    # Enables debug messages
Sanity = False   # If enabled, config commands are not sent to host (show commands are operational)

##########################################################
try:
    emc_vars
except: # If not running on XMC Jython...
    # These lines only needed to run XMC Python script locally (on my laptop)
    # They can also be pasted to XMC, but will not execute
    import sys
    import json
    import java.util
    import emc_cli      # Own local replica
    import emc_nbi      # Own local replica
    import emc_results  # Own local replica
    if len(sys.argv) &gt; 1: # Json file as 1st argv
        emc_vars = json.load(open(sys.argv[1]))
    else:
        emc_vars = json.load(open('emc_vars.json'))
##########################################################

#
# IMPORTS: distributed amongst sections below
#
from distutils.version import LooseVersion

#
# Base functions
# v7
import re                           # Used by scriptName
import time                         # Used by exitError
ExitErrorSleep = 10

def debug(debugOutput): # v1 - Use function to include debugging in script; set above Debug variable to True or False to turn on or off debugging
    if Debug:
        print debugOutput

def exitError(errorOutput, sleep=ExitErrorSleep): # v3 - Exit script with error message and setting status appropriately
    if 'workflowMessage' in emc_vars: # Workflow
        time.sleep(sleep) # When workflow run on multiple devices, want ones that error to be last to complete, so THEY set the workflow message
        emc_results.put("deviceMessage", errorOutput)
        emc_results.put("activityMessage", errorOutput)
        emc_results.put("workflowMessage", errorOutput)
    emc_results.setStatus(emc_results.Status.ERROR)
    raise RuntimeError(errorOutput)

def abortError(cmd, errorOutput): # v1 - A CLI command failed, before bombing out send any rollback commands which may have been set
    print "Aborting script due to error on previous command"
    try:
        rollbackStack()
    finally:
        print "Aborting because this command failed: {}".format(cmd)
        exitError(errorOutput)

def scriptName(): # v1 - Returns the assigned name of the Script or Workflow
    name = None
    if 'workflowName' in emc_vars: # Workflow
        name = emc_vars['workflowName']
    elif 'javax.script.filename' in emc_vars: # Script
        nameMatch = re.search(r'\/([^\/\.]+)\.py$', emc_vars['javax.script.filename'])
        name = nameMatch.group(1) if nameMatch else None
    return name

def workflow_DeviceMessage(msg): # v1 - Set workflow messages appropriately; '&lt;&gt;' is replaced with device IP or list
    singleDeviceMsg = manyDevicesMsg = msg
    if '&lt;&gt;' in msg:
        devicesListStr = emc_vars['devices'][1:-1]
        singleDeviceMsg = msg.replace('&lt;&gt;', emc_vars['deviceIP']).replace('(s)', '').replace('(es)', '')
        if len(devicesListStr.split(',')) &gt; 1:
            manyDevicesMsg = msg.replace('&lt;&gt;', devicesListStr).replace('(s)', 's').replace('(es)', 'es')
        else:
            manyDevicesMsg = singleDeviceMsg
    emc_results.put("deviceMessage", singleDeviceMsg)
    emc_results.put("activityMessage", manyDevicesMsg)
    emc_results.put("workflowMessage", manyDevicesMsg)


#
# Family functions
# v2
Family = None # This needs to get set by setFamily()
FamilyChildren = { # Children will be rolled into parent family for these scripts
    'Extreme Access Series' : 'VSP Series',
    'Unified Switching VOSS': 'VSP Series',
    'Unified Switching EXOS': 'Summit Series',
    'Universal Platform VOSS': 'VSP Series',
    'Universal Platform EXOS': 'Summit Series',
    'Universal Platform Fabric Engine': 'VSP Series',
    'Universal Platform Switch Engine': 'Summit Series',
}

def setFamily(cliDict={}, family=None): # v2 - Set global Family variable; automatically handles family children, as far as this script is concerned
    global Family
    if family:
        Family = family
    elif emc_vars["family"] in FamilyChildren:
        Family = FamilyChildren[emc_vars["family"]]
    else:
        Family = emc_vars["family"]
    print "Using family type '{}' for this script".format(Family)
    if cliDict and Family not in cliDict:
        exitError('This scripts only supports family types: {}'.format(", ".join(list(cliDict.keys()))))
    return Family


#
# CLI functions
# v22
import re
RegexPrompt = re.compile('.*[\?\$%#&gt;]\s?$')
RegexError  = re.compile(
    '^%|\x07|error|invalid|cannot|unable|bad|not found|not exist|not allowed|no such|out of range|incomplete|failed|denied|can\'t|ambiguous|do not|unrecognized',
    re.IGNORECASE | re.MULTILINE
)
RegexNoError  = re.compile( # Messages which would be false positives for an error condition, when they are just a warning..
    'Both ends of MACsec link cannot have the same key-parity value',
    re.IGNORECASE | re.MULTILINE
)
RegexContextPatterns = { # Ported from acli.pl
    'ERS Series' : [
        re.compile('^(?:interface |router \w+$|route-map (?:\"[\w\d\s\.\+-]+\"|[\w\d\.-]+) \d+$|ip igmp profile \d+$|wireless|application|ipv6 dhcp guard policy |ipv6 nd raguard policy )'), # level0
        re.compile('^(?:security|crypto|ap-profile |captive-portal |network-profile |radio-profile )'), # level1
        re.compile('^(?:locale)'), # level2
    ],
    'VSP Series' : [
        re.compile('^ *(?:interface |router \w+$|router vrf|route-map (?:\"[\w\d\s\.\+-]+\"|[\w\d\.-]+) \d+$|application|i-sid \d+|wireless|logical-intf isis \d+|mgmt (?:\d|clip|vlan|oob)|ovsdb$)'), # level0
        re.compile('^ *(?:route-map (?:\"[\w\d\s\.\+-]+\"|[\w\d\.-]+) \d+$)'), # level1
    ],
}
RegexExitInstance = re.compile('^ *(?:exit|back|end|config|save)(?:\s|$)')
Indent = 3 # Number of space characters for each indentation
LastError = None
ConfigHistory = []

def cliError(outputStr): # v1 - Check command output for CLI error message
    if not RegexNoError.search(outputStr) and RegexError.search(outputStr):
        return True
    else:
        return False

def cleanOutput(outputStr): # v3 - Remove echoed command and final prompt from output
    if cliError(outputStr): # Case where emc_cli.send timesout: "Error: session exceeded timeout: 30 secs"
        return outputStr
    lastLine = outputStr.splitlines()[-1:][0]
    if RegexPrompt.match(lastLine):
        lines = outputStr.splitlines()[1:-1]
    else:
        lines = outputStr.splitlines()[1:]
    return '\n'.join(lines)

def configChain(chainStr): # v2 - Produces a list of a set of concatenated commands (either with ';' or newlines)
    chainStr = re.sub(r'\n(\w)(\x0d?\n|\s*;|$)', chr(0) + r'\1\2', chainStr) # Mask trailing "\ny" or "\nn" on commands before making list
    # Checking for \x0d? is necessary when DOS text files are transferred to XIQ-SE, and read and processed locally..
    cmdList = map(str.strip, re.split(r'[;\n]', chainStr))
    cmdList = filter(None, cmdList) # Filter out empty lines, if any
    cmdList = [re.sub(r'\x00(\w)(\x0d?\n|$)', r'\n\1\2', x) for x in cmdList] # Unmask after list made
    return cmdList

def parseRegexInput(cmdRegexStr): # v1 - Parses input command regex for both sendCLI_showRegex() and xmcLinuxCommand()
    # cmdRegexStr format: &lt;type&gt;://&lt;cli-show-command&gt; [&amp; &lt;additional-show-cmd&gt;]||&lt;regex-to-capture-with&gt;
    if re.match(r'\w+(?:-\w+)?://', cmdRegexStr):
        mode, cmdRegexStr = map(str.strip, cmdRegexStr.split('://', 1))
    else:
        mode = None
    cmd, regex = map(str.strip, cmdRegexStr.split('||', 1))
    cmdList = map(str.strip, cmd.split('&amp;'))
    return mode, cmdList, regex

def formatOutputData(data, mode): # v3 - Formats output data for both sendCLI_showRegex() and xmcLinuxCommand()
    if not mode                 : value = data                                   # Legacy behaviour same as list
    elif mode == 'bool'         : value = bool(data)                             # No regex capturing brackets required
    elif mode == 'str'          : value = str(data[0]) if data else None         # Regex should have 1 capturing bracket at most
    elif mode == 'str-lower'    : value = str(data[0]).lower() if data else None # Same as str but string made all lowercase
    elif mode == 'str-upper'    : value = str(data[0]).upper() if data else None # Same as str but string made all uppercase
    elif mode == 'str-join'     : value = ''.join(data)                          # Regex with max 1 capturing bracket, joins list to string
    elif mode == 'str-nwlnjoin' : value = "\n".join(data)                        # Regex with max 1 capturing bracket, joins list to multi-line string
    elif mode == 'int'          : value = int(data[0]) if data else None         # Regex must have 1 capturing bracket at most
    elif mode == 'list'         : value = data                                   # If &gt; 1 capturing brackets, will be list of tuples
    elif mode == 'list-reverse' : value = list(reversed(data))                   # Same as list but in reverse order
    elif mode == 'list-diagonal': value = [data[x][x] for x in range(len(data))] # Regex pat1|pat2 = list of tuples; want [0][0],[1][1],etc
    elif mode == 'tuple'        : value = data[0] if data else ()                # Regex &gt; 1 capturing brackets, returns 1st tuple
    elif mode == 'dict'         : value = dict(data)                             # Regex must have 2 capturing brackets exactly
    elif mode == 'dict-reverse' : value = dict(map(reversed, data))              # Same as dict, but key/values will be flipped
    elif mode == 'dict-both'    : value = dict(data), dict(map(reversed, data))  # Returns 2 dict: dict + dict-reverse
    elif mode == 'dict-diagonal': value = dict((data[x][x*2],data[x][x*2+1]) for x in range(len(data))) # {[0][0]:[0][1], [1][2]:[1][3], etc}
    elif mode == 'dict-sequence': value = dict((data[x*2][0],data[x*2+1][1]) for x in range(len(data)/2)) # {[0][0]:[1][1], [2][0]:[3][1], etc}
    else:
        RuntimeError("formatOutputData: invalid scheme type '{}'".format(mode))
    return value

def sendCLI_showCommand(cmd, returnCliError=False, msgOnError=None): # v2 - Send a CLI show command; return output
    global LastError
    resultObj = emc_cli.send(cmd)
    if resultObj.isSuccess():
        outputStr = cleanOutput(resultObj.getOutput())
        if outputStr and cliError("\n".join(outputStr.split("\n")[:4])): # If there is output, check for error in 1st 4 lines only (timestamp banner might shift it by 3 lines)
            if returnCliError: # If we asked to return upon CLI error, then the error message will be held in LastError
                LastError = outputStr
                if msgOnError:
                    print "==&gt; Ignoring above error: {}\n\n".format(msgOnError)
                return None
            abortError(cmd, outputStr)
        LastError = None
        return outputStr
    else:
        exitError(resultObj.getError())

def sendCLI_showRegex(cmdRegexStr, debugKey=None, returnCliError=False, msgOnError=None): # v1 - Send show command and extract values from output using regex
    # Regex is by default case-sensitive; for case-insensitive include (?i) at beginning of regex on input string
    mode, cmdList, regex = parseRegexInput(cmdRegexStr)
    for cmd in cmdList:
        # If cmdList we try each command in turn until one works; we don't want to bomb out on cmds before the last one in the list
        ignoreCliError = True if len(cmdList) &gt; 1 and cmd != cmdList[-1] else returnCliError
        outputStr = sendCLI_showCommand(cmd, ignoreCliError, msgOnError)
        if outputStr:
            break
    if not outputStr: # returnCliError true
        return None
    data = re.findall(regex, outputStr, re.MULTILINE)
    debug("sendCLI_showRegex() raw data = {}".format(data))
    # Format we return data in depends on what '&lt;type&gt;://' was pre-pended to the cmd &amp; regex
    value = formatOutputData(data, mode)
    if Debug:
        if debugKey: debug("{} = {}".format(debugKey, value))
        else: debug("sendCLI_showRegex OUT = {}".format(value))
    return value

def sendCLI_configCommand(cmd, returnCliError=False, msgOnError=None, waitForPrompt=True): # v3 - Send a CLI config command
    global LastError
    cmdStore = re.sub(r'\n.+$', '', cmd) # Strip added CR+y or similar
    if Sanity:
        print "SANITY&gt; {}".format(cmd)
        ConfigHistory.append(cmdStore)
        LastError = None
        return True
    resultObj = emc_cli.send(cmd, waitForPrompt)
    if resultObj.isSuccess():
        outputStr = cleanOutput(resultObj.getOutput())
        if outputStr and cliError("\n".join(outputStr.split("\n")[:4])): # If there is output, check for error in 1st 4 lines only
            if returnCliError: # If we asked to return upon CLI error, then the error message will be held in LastError
                LastError = outputStr
                if msgOnError:
                    print "==&gt; Ignoring above error: {}\n\n".format(msgOnError)
                return False
            abortError(cmd, outputStr)
        ConfigHistory.append(cmdStore)
        LastError = None
        return True
    else:
        exitError(resultObj.getError())

def sendCLI_configChain(chainStr, returnCliError=False, msgOnError=None, waitForPrompt=True, abortOnError=True): # v4 - Send a list of config commands
    # Syntax: chainStr can be a multi-line string where individual commands are on new lines or separated by the semi-colon ";" character
    # Some embedded directive commands are allowed, these must always begin with the hash "#" character:
    # #error fail       : If a subsequent command generates an error, make the entire script fail
    # #error stop       : If a subsequent command generates an error, do not fail the script but stop processing firther commands
    # #error continue   : If a subsequent command generates an error, ignore it and continue executing remaining commands
    cmdList = configChain(chainStr)
    successStatus = True
    for cmd in cmdList[:-1]: # All but last
        embedded = re.match(r'^#error +(fail|stop|continue) *$', cmd)
        if embedded:
            errorMode = embedded.group(1)
            returnCliError = False if errorMode == 'fail' else True
            abortOnError = True if errorMode == 'stop' else False
            continue # After setting the above, we skip the embedded command
        success = sendCLI_configCommand(cmd, returnCliError, msgOnError)
        if not success:
            successStatus = False
            if abortOnError:
                return False
    # Last now
    success = sendCLI_configCommand(cmdList[-1], returnCliError, msgOnError, waitForPrompt)
    if not success:
        return False
    return successStatus

def printConfigSummary(): # v3 - Print summary of all config commands executed with context indentation
    global ConfigHistory
    emc_cli.close()
    if not len(ConfigHistory):
        print "No configuration was performed"
        return
    print "The following configuration was successfully performed on switch:"
    indent = ''
    level = 0
    if Family in RegexContextPatterns:
        maxLevel = len(RegexContextPatterns[Family])
    for cmd in ConfigHistory:
        if Family in RegexContextPatterns:
            if RegexContextPatterns[Family][level].match(cmd):
                print "-&gt; {}{}".format(indent, cmd)
                if level + 1 &lt; maxLevel:
                    level += 1
                indent = ' ' * Indent * level
                continue
            elif RegexExitInstance.match(cmd):
                if level &gt; 0:
                    level -= 1
                indent = ' ' * Indent * level
        print "-&gt; {}{}".format(indent, cmd)
    ConfigHistory = []


#
# XMC GraphQl NBI functions
# v11
from java.util import LinkedHashMap # Used by nbiQuery
LastNbiError = None
NbiUrl = None

def recursionKeySearch(nestedDict, returnKey): # v1 - Used by both nbiQuery() and nbiMutation()
    for key, value in nestedDict.iteritems():
        if key == returnKey:
            return True, value
    for key, value in nestedDict.iteritems():
        if isinstance(value, (dict, LinkedHashMap)): # XMC Python is Jython where a dict is in fact a java.util.LinkedHashMap
            foundKey, foundValue = recursionKeySearch(value, returnKey)
            if foundKey:
                return True, foundValue
        return [None, None] # If we find nothing

def nbiQuery(jsonQueryDict, debugKey=None, returnKeyError=False, **kwargs): # v5 - Makes a GraphQl query of XMC NBI; if returnKey provided returns that key value, else return whole response
    global LastNbiError
    jsonQuery = jsonQueryDict['json']
    for key in kwargs:
        jsonQuery = jsonQuery.replace('&lt;'+key+'&gt;', kwargs[key])
    returnKey = jsonQueryDict['key'] if 'key' in jsonQueryDict else None
    response = nbiSessionPost(jsonQuery, returnKeyError) if NbiUrl else emc_nbi.query(jsonQuery)
    debug("nbiQuery response = {}".format(response))
    if response == None: # Should only happen from nbiSessionPost if returnKeyError=True
        return None
    if 'errors' in response: # Query response contains errors
        if returnKeyError: # If we asked to return upon NBI error, then the error message will be held in LastNbiError
            LastNbiError = response['errors'][0].message
            return None
        abortError("nbiQuery for\n{}".format(jsonQuery), response['errors'][0].message)
    LastNbiError = None

    if returnKey: # If a specific key requested, we find it
        foundKey, returnValue = recursionKeySearch(response, returnKey)
        if foundKey:
            if Debug:
                if debugKey: debug("{} = {}".format(debugKey, returnValue))
                else: debug("nbiQuery {} = {}".format(returnKey, returnValue))
            return returnValue
        if returnKeyError:
            return None
        # If requested key not found, raise error
        abortError("nbiQuery for\n{}".format(jsonQuery), 'Key "{}" was not found in query response'.format(returnKey))

    # Else, return the full response
    if Debug:
        if debugKey: debug("{} = {}".format(debugKey, response))
        else: debug("nbiQuery response = {}".format(response))
    return response

def nbiMutation(jsonQueryDict, returnKeyError=False, debugKey=None, **kwargs): # v5 - Makes a GraphQl mutation query of XMC NBI; returns true on success
    global LastNbiError
    jsonQuery = jsonQueryDict['json']
    for key in kwargs:
        jsonQuery = jsonQuery.replace('&lt;'+key+'&gt;', kwargs[key])
    returnKey = jsonQueryDict['key'] if 'key' in jsonQueryDict else None
    if Sanity:
        print "SANITY - NBI Mutation:\n{}\n".format(jsonQuery)
        LastNbiError = None
        return True
    print "NBI Mutation Query:\n{}\n".format(jsonQuery)
    response = nbiSessionPost(jsonQuery, returnKeyError) if NbiUrl else emc_nbi.query(jsonQuery)
    debug("nbiQuery response = {}".format(response))
    if 'errors' in response: # Query response contains errors
        if returnKeyError: # If we asked to return upon NBI error, then the error message will be held in LastNbiError
            LastNbiError = response['errors'][0].message
            return None
        abortError("nbiQuery for\n{}".format(jsonQuery), response['errors'][0].message)

    def recursionStatusSearch(nestedDict):
        for key, value in nestedDict.iteritems():
            if key == 'status':
                if 'message' in nestedDict:
                    return True, value, nestedDict['message']
                else:
                    return True, value, None
        for key, value in nestedDict.iteritems():
            if isinstance(value, (dict, LinkedHashMap)): # XMC Python is Jython where a dict is in fact a java.util.LinkedHashMap
                foundKey, foundValue, foundMsg = recursionStatusSearch(value)
                if foundKey:
                    return True, foundValue, foundMsg
            return [None, None, None] # If we find nothing

    foundKey, returnStatus, returnMessage = recursionStatusSearch(response)
    if foundKey:
        debug("nbiMutation status = {} / message = {}".format(returnStatus, returnMessage))
    elif not returnKeyError:
        # If status key not found, raise error
        abortError("nbiMutation for\n{}".format(jsonQuery), 'Key "status" was not found in query response')

    if returnStatus == "SUCCESS":
        LastNbiError = None
        if returnKey: # If a specific key requested, we find it
            foundKey, returnValue = recursionKeySearch(response, returnKey)
            if foundKey:
                if Debug:
                    if debugKey: debug("{} = {}".format(debugKey, returnValue))
                    else: debug("nbiQuery {} = {}".format(returnKey, returnValue))
                return returnValue
            if returnKeyError:
                return None
            # If requested key not found, raise error
            abortError("nbiMutation for\n{}".format(jsonQuery), 'Key "{}" was not found in mutation response'.format(returnKey))
        return True
    else:
        LastNbiError = returnMessage
        return False


#
# Port processing functions
# v5
RegexPort = re.compile('^(?:[1-9]\d{0,2}[/:])?\d+(?:[/:]\d)?$')
RegexPortRange = re.compile('^(?:([1-9]\d{0,2})([/:]))?(\d+)(?:[/:](\d))?-(?:([1-9]\d{0,2})[/:])?(\d+)(?:[/:](\d))?$')
RegexStarRange = re.compile('^([1-9]\d{0,2})(:)\*$') # XOS only
SlotPortRange = None # Gets set to dict by getSlotPortRanges()

def portValue(port): # v1 - Function to pass to sorted(key) to sort port lists
    slotPort = re.split('[/:]', port)
    if len(slotPort) == 3: # slot/port/chan format
        idx = int(slotPort[0])*400 + int(slotPort[1])*4 + int(slotPort[2])
    elif len(slotPort) == 2: # slot/port format
        idx = int(slotPort[0])*400 + int(slotPort[1])*4
    else: # standalone port (no slot)
        idx = int(slotPort[0])*4
    return idx

def getSlotPortRanges(): # v1 - Populates the SlotPortRange dict
    global SlotPortRange
    slotCommand = {'Summit Series': 'dict://show slot||^Slot-(\d+) +\S+ +\S+ +\S+ +(\d+)'} # Only XOS supported
    if Family not in slotCommand:
        SlotPortRange = {}
        return
    SlotPortRange = sendCLI_showRegex(slotCommand[Family])
    debug("getSlotPortRanges = {}".format(SlotPortRange))

def generatePortList(portStr, debugKey=None): # v2 - Given a port list/range, validates it and returns an ordered port list with no duplicates (can also be used for VLAN-id ranges)
    # This version of this function will not handle port ranges which span slots
    debug("generatePortList IN = {}".format(portStr))
    portDict = {} # Use a dict, will ensure no port duplicate keys
    for port in portStr.split(','):
        port = re.sub(r'^[\s\(]+', '', port) # Remove leading spaces  [ or '(' ]
        port = re.sub(r'[\s\)]+$', '', port) # Remove trailing spaces [ or ')' =&gt; XMC bug on ERS standalone units]
        if not len(port): # Skip empty string
            continue
        rangeMatch = RegexPortRange.match(port)
        starMatch = RegexStarRange.match(port)
        if rangeMatch: # We have a range of ports
            startSlot = rangeMatch.group(1)
            separator = rangeMatch.group(2)
            startPort = int(rangeMatch.group(3))
            startChan = int(rangeMatch.group(4))
            endSlot = rangeMatch.group(5)
            endPort = int(rangeMatch.group(6))
            endChan = int(rangeMatch.group(7))
            if endSlot and startSlot != endSlot:
                print "ERROR! generatePortList no support for ranges spanning slots: {}".format(port)
            elif (startChan or endChan) and endPort and startPort != endPort:
                print "ERROR! generatePortList no support for ranges spanning channelized ports: {}".format(port)
            elif not (startChan or endChan) and startPort &gt;= endPort:
                print "ERROR! generatePortList invalid range: {}".format(port)
            elif (startChan or endChan) and startChan &gt;= endChan:
                print "ERROR! generatePortList invalid range: {}".format(port)
            else: # We are good
                if startChan:
                    for portCount in range(startChan, endChan + 1):
                        portDict[startSlot + separator + str(startPort) + separator + str(portCount)] = 1
                else:
                    for portCount in range(startPort, endPort + 1):
                        if startSlot: # slot-based range
                            portDict[startSlot + separator + str(portCount)] = 1
                        else: # simple port range (no slot info)
                            portDict[str(portCount)] = 1
        elif starMatch: # We have a slot/* range
            slot = starMatch.group(1)
            separator = starMatch.group(2)
            if SlotPortRange == None: # Structure not populated
                getSlotPortRanges()
            if SlotPortRange:
                if slot in SlotPortRange:
                    for portCount in range(1, int(SlotPortRange[slot]) + 1):
                        portDict[slot + separator + str(portCount)] = 1
                else:
                    print "Warning: no range for slot {}; skipping: {}".format(slot, port)
            else:
                print "Warning: generatePortList skipping star range as not supported on this switch type: {}".format(port)
        elif RegexPort.match(port): # Port is in valid format
            portDict[port] = 1
        else: # Port is in an invalid format; don't add to dict, print an error message, don't raise exception 
            print "Warning: generatePortList skipping unexpected port format: {}".format(port)

    # Sort and return the list as a comma separated string
    portList = sorted(portDict, key=portValue)

    if Debug:
        if debugKey: debug("{} = {}".format(debugKey, portList))
        else: debug("generatePortList OUT = {}".format(portList))
    return portList

def generatePortRange(portList, debugKey=None): # v2 - Given a list of ports, generates a compacted port list/range string for use on CLI commands
    # Ported from acli.pl; this version of this function only compacts ranges within same slot
    debug("generatePortRange IN = {}".format(portList))
    rangeMode = {'VSP Series': 2, 'ERS Series': 1, 'Summit Series': 1}
    elementList = []
    elementBuild = None
    currentType = None
    currentSlot = None
    currentPort = None
    currentChan = None
    rangeLast = None

    # First off, sort the list
    portList = sorted(portList, key=portValue)
    for port in portList:
        slotPort = re.split("([/:])", port) # Split on '/' (ERS/VSP) or ':'(XOS)
        # slotPort[0] = slot / slotPort[1] = separator ('/' or ':') / slotPort[2] = port / slotPort[4] = channel
        if len(slotPort) == 5: # slot/port/chan
            if elementBuild:
                if currentType == 's/p' and slotPort[0] == currentSlot and slotPort[2] == currentPort and slotPort[4] == str(int(currentChan)+1):
                    currentChan = slotPort[4]
                    if rangeMode[Family] == 1:
                        rangeLast = currentChan
                    else: # rangeMode = 2
                        rangeLast = currentSlot + slotPort[1] + currentPort + slotPort[1] + currentChan
                    continue
                else: # Range complete
                    if rangeLast:
                        elementBuild += '-' + rangeLast
                    elementList.append(elementBuild)
                    elementBuild = None
                    rangeLast = None
                    # Fall through below
            currentType = 's/p'
            currentSlot = slotPort[0]
            currentPort = slotPort[2]
            currentChan = slotPort[4]
            elementBuild = port

        if len(slotPort) == 3: # slot/port
            if elementBuild:
                if currentType == 's/p' and slotPort[0] == currentSlot and slotPort[2] == str(int(currentPort)+1) and not currentChan:
                    currentPort = slotPort[2]
                    if rangeMode[Family] == 1:
                        rangeLast = currentPort
                    else: # rangeMode = 2
                        rangeLast = currentSlot + slotPort[1] + currentPort
                    continue
                else: # Range complete
                    if rangeLast:
                        elementBuild += '-' + rangeLast
                    elementList.append(elementBuild)
                    elementBuild = None
                    rangeLast = None
                    # Fall through below
            currentType = 's/p'
            currentSlot = slotPort[0]
            currentPort = slotPort[2]
            currentChan = None
            elementBuild = port

        if len(slotPort) == 1: # simple port (no slot)
            if elementBuild:
                if currentType == 'p' and port == str(int(currentPort)+1):
                    currentPort = port
                    rangeLast = currentPort
                    continue
                else: # Range complete
                    if rangeLast:
                        elementBuild += '-' + rangeLast
                    elementList.append(elementBuild)
                    elementBuild = None
                    rangeLast = None
                    # Fall through below
            currentType = 'p'
            currentPort = port
            elementBuild = port

    if elementBuild: # Close off last element we were holding
        if rangeLast:
            elementBuild += '-' + rangeLast
        elementList.append(elementBuild)

    portStr = ','.join(elementList)
    if Debug:
        if debugKey: debug("{} = {}".format(debugKey, portStr))
        else: debug("generatePortRange OUT = {}".format(portStr))
    return portStr


#
# Other Custom Functions
#
def getIsidUniStruct(isid): # v1 - Extract all port members of an I-SID
    # Only supported for family = 'VSP Series'
    # the "show i-sid" command is too fiddly to scrape...
    # the "show interfaces gigabitEthernet i-sid" command does not show I-SIDs with no ports assigned...
    # so we use "show run module i-sid" instead...
    cliOutput = sendCLI_showCommand(CLI_Dict[Family]['get_isid_uni_data'].format(isid))
    isidPorts = {}
    foundIsidData = False
    for line in cliOutput.splitlines():
        if foundIsidData:
            matchObj = re.match(r'c-vid (\d+) (port|mlt) (\S+)', line)
            if matchObj:
                tagging = 'tag'
                cvlan = matchObj.group(1)
                btype = matchObj.group(2)
                if btype == 'port':
                    ports = matchObj.group(3)
                    mlt = None
                else:
                    ports = None
                    mlt = matchObj.group(3)
            else:
                matchObj = re.match(r'untagged-traffic (port|mlt) (\S+)', line)
                if matchObj:
                    tagging = 'untag'
                    cvlan = None
                    btype = matchObj.group(1)
                    if btype == 'port':
                        ports = matchObj.group(2)
                        mlt = None
                    else:
                        ports = None
                        mlt = matchObj.group(2)
                else:
                    matchObj = re.match(r'(port|mlt) (\S+)', line)
                    if matchObj:
                        tagging = 'transparent'
                        cvlan = None
                        btype = matchObj.group(1)
                        if btype == 'port':
                            ports = matchObj.group(2)
                            mlt = None
                        else:
                            ports = None
                            mlt = matchObj.group(2)
                    elif re.match(r'exit', line):
                        break # We come out!
                    else:
                        continue
            if ports:
                portList = generatePortList(ports)
                debug("portList = {}".format(portList))
                for port in portList:
                    isidPorts[port] = {'type': tagging, 'vlan': cvlan}
            if mlt:
                isidPorts[mlt] = {'type': tagging, 'vlan': cvlan}

        elif re.match(r'^i-sid {} '.format(isid), line):
            isidPorts['exists'] = True
            foundIsidData = True
            continue
        else: # Other line, skip
            continue

    debug("getIsidUniStruct OUT = {}".format(isidPorts))
    return isidPorts


#
# INIT: Init Debug &amp; Sanity flags based on input combos
#
try:
    if emc_vars['userInput_sanity'].lower() == 'enable':
        Sanity = True
    elif emc_vars['userInput_sanity'].lower() == 'disable':
        Sanity = False
except:
    pass
try:
    if emc_vars['userInput_debug'].lower() == 'enable':
        Debug = True
    elif emc_vars['userInput_debug'].lower() == 'disable':
        Debug = False
except:
    pass


# --&gt; Insert Ludo Threads library here if required &lt;--


# --&gt; XMC Python script actually starts here &lt;--


#
# Variables:
#
CLI_Dict = {
    'VSP Series': {
        'disable_more_paging'        : 'terminal more disable',
        'enable_context'             : 'enable',
        'config_context'             : 'config term',
        'exit_config_context'        : 'exit',
        'end_config'                 : 'end',
        'save_config'                : 'save config',
        'get_dvr_type'               : 'str-lower://show dvr||^Role +: +(Leaf|Controller)',
        'get_auto_sense_status'      : 'dict://show interfaces gigabitEthernet auto-sense {}||^(\d+/\d+(?:/\d+)?) +(\S+)', # Port
        'get_flex_uni'               : 'dict://show interfaces gigabitEthernet config {}||^(\d+/\d+(?:/\d+)?) +\S+ +\S+ +\S+ +\S+ +\S+ +(Enable|Disable)', # Port
        'get_mlt_flex_uni'           : 'dict://show mlt||^(\d+)\s+\d+\s+\S+\s+\S+\s+\S+\s+\S+\s+\S+\s+(enable|disable)',
        'get_mlt_tagging'            : 'dict://show mlt||^(\d+) +\d+.+?(access|trunk)',
        'create_flex_uni'            : 'vlan members remove 1 {0}; interface gigabitEthernet {0}; flex-uni enable; no shutdown; exit', # Port
        'create_mlt_flex_uni'        : 'interface mlt {0}; flex-uni enable; exit', # MLT id
        'get_cvlan_name'             : 'str://show vlan basic {0}||^{0}\s+(\S+)\s', # VLAN id
        'create_cvlan'               : 'vlan create {0} type port-mstprstp 0', # {0} = VLAN id
        'get_cvlan_isid'             : 'str://show vlan i-sid {0}||^{0}\s+(\d+)', # VLAN id
        'set_cvlan_isid'             : 'vlan i-sid {0} {1}', # {0} = VLAN id; {1} = i-sid
        'disable_autosense'          : 'interface gigabitEthernet {0}; no auto-sense enable; exit', # Port
        'set_cvlan_name'             : 'vlan name {0} {1}', # {0} = VLAN id; {1} = Name
        'create_cvlan_uni'           : { # {0} = VLAN id; {1} = port-list
            'tag'                    : 'interface gigabitEthernet {1}; encapsulation dot1q; exit; vlan members add {0} {1}',
            'untag'                  : 'interface gigabitEthernet {1}; no encapsulation dot1q; exit; vlan members add {0} {1}',
                                       },
        'create_cvlan_mlt_uni'       : 'vlan mlt {} {}', # VLAN id, MLT id
        'get_isid_uni_data'          : 'show running-config module i-sid',
        'create_switched_isid_y'     : 'i-sid {0}\ny', # {0} = i-sid
        'create_switched_isid'       : 'i-sid {0}', # {0} = i-sid
        'create_switched_uni'        : { # {0} = VLAN id; {1} = port-list
            'tag'                    : 'c-vid {0} port {1}',
            'untag'                  : 'untagged-traffic port {1}',
                                       },
        'create_mlt_switched_uni'    : { # {0} = VLAN id; {1} = MLT-id
            'tag'                    : 'c-vid {0} mlt {1}',
            'untag'                  : 'untagged-traffic mlt {1}',
                                       },
        'delete_switched_uni'        : { # {0} = i-sid; {1} = VLAN id; {2} = port-list
            'tag'                    : 'i-sid {0}; no c-vid {1} port {2}; exit',
            'untag'                  : 'i-sid {0}; no untagged-traffic port {2}; exit',
            'transparent'            : 'i-sid {0}; no port {2}; exit'
                                       },
        'delete_mlt_switched_uni'    : { # {0} = i-sid; {1} = VLAN id; {2} = MLT id
            'tag'                    : 'i-sid {0}; no c-vid {1} mlt {2}; exit',
            'untag'                  : 'i-sid {0}; no untagged-traffic mlt {2}; exit',
            'transparent'            : 'i-sid {0}; no mlt {2}; exit'
                                       },
        'set_isid_name'              : 'i-sid name {} "{}"', # I-SID, Name
    },
    'Summit Series': {
        'disable_more_paging'        : 'disable clipaging',
        'save_config'                : 'save configuration',
        'get_cvlan_name'             : 'str://show vlan||^(\S+)\s+{0}\s', # VLAN id
        'create_cvlan'               : 'create vlan {0}', # {0} = VLAN id
        'get_cvlan_isid'             : 'str://show vlan {0} fabric attach assignments &amp; show fabric attach vlan {0} assignments||^\s+{0}\s+\S+\s+(?:Static|Dynamic)\s+(\d+)', # VLAN id
        'set_cvlan_isid'             : 'configure vlan {0} add isid {1}', # {0} = VLAN id; {1} = i-sid 
        'set_cvlan_name'             : 'configure vlan {0} name {1}', # {0} = VLAN id; {1} = Name
        'create_cvlan_uni'           : { # {0} = VLAN id; {1} = port-list
            'tag'                    : 'configure vlan {0} add ports {1} tagged',
            'untag'                  : 'configure vlan {0} add ports {1} untagged',
                                       },
    },
    'ERS Series': {
        'disable_more_paging'        : 'terminal length 0',
        'enable_context'             : 'enable',
        'config_context'             : 'config term',
        'end_config'                 : 'end',
        'save_config'                : 'copy config nvram',
        'get_vlan_configcontrol'     : 'str-lower://show vlan configcontrol||VLAN Control:\s+(\S+)',
        'get_cvlan_name'             : 'str://show vlan||^{0}\s+(\S.+\S)\s+Port', # VLAN id
        'set_vlan_configcontrol'     : 'vlan configcontrol {}', # Mode
        'create_cvlan'               : 'vlan create {0} type port', # {0} = VLAN id
        'get_cvlan_isid'             : 'str://show vlan i-sid {0}||^{0}\s+(\d+)', # VLAN id
        'set_cvlan_isid'             : 'i-sid {1} vlan {0}', # {0} = VLAN id; {1} = i-sid 
        'set_cvlan_name'             : 'vlan name {0} {1}', # {0} = VLAN id; {1} = Name
        'create_cvlan_uni'           : { # {0} = VLAN id; {1} = port-list
            'tag'                    : 'vlan ports {1} tagging tagAll; vlan members add {0} {1}',
            'untag'                  : 'vlan ports {1} tagging untagAll; vlan members add {0} {1}',
                                       },
    },
}

NBI_Query = { # GraphQl query / NBI_Query['key'].replace('&lt;IP&gt;', var)
    'rediscover_device': {
        'json': '''
                mutation {
                  network {
                    rediscoverDevices(input: {devices: {ipAddress: "&lt;IP&gt;"}}) {
                      status
                      message
                    }
                  }
                }
                ''',
    },
   'reload_device': {
        'json': '''
                mutation {
                  network {
                    reloadDevices(input: {
                      devices:{
                        ipAddress: "&lt;IP&gt;"
                      }
                    }) {
                      message
                      status
                    }
                  }
                }
                ''',
    },
}


def main():
    print "Create L2VSN version {}".format(__version__)
    setFamily() # Sets global Family variable

    isid      = emc_vars["userInput_isid"].strip()
    try:
        vlanName = emc_vars["userInput_vlanName"].strip()
    except:
        vlanName = None
    try:
        vlanGb = emc_vars["userInput_vlanGlobal"].strip()
    except:
        vlanGb = None
    try:
        portsGb = emc_vars["userInput_portsGlobal"].strip()
    except:
        portsGb = None
    try:
        mltsGb = emc_vars["userInput_mltsGlobal"].strip()
    except:
        mltsGb = None
    try:
        taggingGb = emc_vars["userInput_tagGlobal"]
    except:
        taggingGb = None
    try:
        vlanDv = emc_vars["userInput_vlan"].strip()
    except:
        vlanDv = None
    try:
        portsDv = emc_vars["userInput_ports"].strip()
    except:
        portsDv = None
    try:
        mltsDv = emc_vars["userInput_mlts"].strip()
    except:
        mltsDv = None
    try:
        taggingDv = emc_vars["userInput_tag"]
    except:
        taggingDv = None

    print "Information provided by User:"
    print " Global settings:"
    print " - I-SID = {}".format(isid)
    print " - VLAN Name = {}".format(vlanName)
    print " - Global VLAN = {}".format(vlanGb)
    print " - Global Ports = {}".format(portsGb)
    print " - Global MLT ids = {}".format(mltsGb)
    print " - Global Tagging mode = {}".format(taggingGb)
    print " Device override settings:"
    print " - VLAN = {}".format(vlanDv)
    print " - Ports = {}".format(portsDv)
    print " - MLT ids = {}".format(mltsDv)
    print " - Tagging mode = {}".format(taggingDv)

    # I-SID validation
    if not isid.isdigit() or int(isid) &gt; 15999999:
        exitError('Invalid I-SID value {}; needs to be a number not higher than 15999999'.format(isid))

    # VLAN name validation
    if vlanName and re.search(r'\s', vlanName):
        exitError('Invalid VLAN Name "{}"; must not contain any spaces'.format(vlanName))

    # Determine VLAN, Ports and tagging to use
    if taggingDv:
        tagging = taggingDv
    elif taggingGb:
        tagging = taggingGb
    else:
        tagging = 'tag'

    if vlanDv:
        vlan = vlanDv
    elif vlanGb:
        vlan = vlanGb
    else:
        vlan = None
    if vlan and (not vlan.isdigit() or int(vlan) &gt; 4095):
        exitError('Invalid VLAN id value {}; needs to be a number not higher than 4095'.format(vlan))

    if portsDv:
        ports = portsDv
    elif portsGb:
        ports = portsGb
    else:
        ports = None

    if ports and not vlan and tagging == 'tag':
        exitError('VLAN-id must be provided for tagged termination !!')

    if mltsDv:
        if Family != 'VSP Series':
            exitError('This script only supports MLT ids with VOSS VSPs; not with {}'.format(Family))
        mlts = mltsDv
    elif mltsGb:
        if Family == 'VSP Series':
            mlts = mltsGb
        else:
            print 'MLTs not supported on family "{}"; resetting to None'.format(Family)
            mlts = None
    else:
        mlts = None
    if mlts:
        mltList = generatePortList(mlts)
    else:
        mltList = []
    debug("mltList = {}".format(mltList))
    for mlt in mltList:
        if not mlt.isdigit() or int(mlt) &gt; 512:
            exitError('Invalid MLT id value {}; needs to be a number not higher than 512'.format(mlt))

    # Disable more paging (generatePortList might issue a CLI command, so do this before)
    sendCLI_showCommand(CLI_Dict[Family]['disable_more_paging'])

    # Obtain ports in list and range format
    if ports:
        portList = generatePortList(ports)
        portRange = generatePortRange(portList)
    else:
        portList = []
        portRange = ''
    debug("portList = {}".format(portList))
    debug("portRange = {}".format(portRange))

    # Enter privExec, for show commands
    if 'enable_context' in CLI_Dict[Family]:
        sendCLI_showCommand(CLI_Dict[Family]['enable_context'])

    cvlanPortList = []
    swuniPortList = []
    cvlanPortRange = ''
    swuniPortRange = ''
    cvlanMltList = []
    swuniMltList = []
    cvlanAloneCreate = False
    swuniAloneCreate = False
    swuniVlan = vlan
    dvrLeaf = False
    autoSensePortDict = {}
    flexUniPortDict = None
    flexUniMltDict = None
    vlanCfgCtrl = None
    vlanIsid = None

    if Family == 'VSP Series':

        # Table to determine type of L2VSN we need to create
        # Input Ports | DVR Leaf | Auto-Sense | Flex-uni   | Type to create
        #    yes      |   yes    | don't care | don't care | =&gt; create Switched-UNI
        #    yes      |   no     |    yes     | don't care | =&gt; create CVLAN-UNI
        #    yes      |   no     |    no      |    yes     | =&gt; create Switched-UNI
        #    yes      |   no     |    no      |    no      | =&gt; create CVLAN-UNI
        #    no       |   yes    |    no      |    no      | =&gt; create Switched-UNI
        #    no       |   no     |    no      |    no      | =&gt; create CVLAN-UNI

        # Get DVR node type
        dvrNodeType = sendCLI_showRegex(CLI_Dict[Family]['get_dvr_type'], 'dvrNodeType')
        if dvrNodeType == 'leaf':
            dvrLeaf = True 

        # Determine what type of L2VSN we need to create
        if portList:
            # Get auto-sense status for all ports
            autoSensePortDict = sendCLI_showRegex(CLI_Dict[Family]['get_auto_sense_status'].format(portRange), 'autoSensePortDict', True)
            # Get flex-uni port status for all ports
            flexUniPortDict = sendCLI_showRegex(CLI_Dict[Family]['get_flex_uni'].format(portRange), 'flexUniPortDict')

            # Check Port validity
            for port in portList:
                if port not in flexUniPortDict:
                    exitError('Entered Port {} does not exist on switch!'.format(port))

            if dvrLeaf:
                swuniPortList = portList
            else:
                for port in portList:
                    if autoSensePortDict[port] == 'Enable':
                        cvlanPortList.append(port)
                    elif flexUniPortDict[port] == 'Enable':
                        swuniPortList.append(port)
                    else: # flexUniPortDict[port] == 'Disable'
                        cvlanPortList.append(port)
            debug("swuniPortList = {}".format(swuniPortList))
            debug("cvlanPortList = {}".format(cvlanPortList))
            if swuniPortList:
                swuniPortRange = generatePortRange(swuniPortList)
                print "\nThe following ports will be configured with Switched-UNI: {}".format(swuniPortRange)
            if cvlanPortList:
                cvlanPortRange = generatePortRange(cvlanPortList)
                print "\nThe following ports will be configured with CVLAN-UNI: {}".format(cvlanPortRange)
            if swuniPortList or cvlanPortList:
                print "\n"

        if mltList:
            # Get flex-uni port status for all MLTs
            flexUniMltDict = sendCLI_showRegex(CLI_Dict[Family]['get_mlt_flex_uni'], 'flexUniMltDict')

            # Check MLT existence
            for mlt in mltList:
                if mlt not in flexUniMltDict:
                    exitError('Entered MLT id {} does not exist on switch; this script can only terminate L2VSNs on already existing MLTs'.format(mlt))

            if dvrLeaf:
                swuniMltList = mltList
            else:
                for mlt in mltList:
                    if flexUniMltDict[port] == 'Enable':
                        swuniMltList.append(port)
                    else: # flexUniMltDict[port] == 'Disable'
                        cvlanMltList.append(port)
            debug("swuniMltList = {}".format(swuniMltList))
            debug("cvlanMltList = {}".format(cvlanMltList))
            if swuniMltList:
                print "\nThe following MLTs will be configured with Switched-UNI: {}".format(swuniMltList)
            if cvlanMltList:
                print "\nThe following MLTs will be configured with CVLAN-UNI: {}".format(cvlanMltList)
            if swuniMltList or cvlanMltList:
                print "\n"

        if not portList and not mltList:
            if dvrLeaf:
                swuniAloneCreate = True
                print "\nNo input ports provided and switch is DVR Leaf =&gt; Switched-UNI context creation only\n"
            else:
                cvlanAloneCreate = True
                print "\nNo input ports provided and switch is not DVR Leaf =&gt; Platform CVLAN creation only\n"

    else: # ERS,XOS
        cvlanPortList = portList
        if cvlanPortList:
            cvlanPortRange = generatePortRange(cvlanPortList)
            print "\nThe following ports will be configured with Fabric Attach CVLAN-UNI: {}\n".format(cvlanPortRange)
        else:
            cvlanAloneCreate = True
            print "\nNo input ports provided =&gt; Platform CVLAN creation only\n"

    # Some extra validation
    if not vlan and tagging == 'untag' and cvlanPortList:
        exitError('VLAN-id must be provided for CVLAN untagged termination !!')
    if swuniVlan and tagging == 'untag' and (swuniPortList or swuniMltList):
        # User entered a VLAN value, but we don't need one and we need to check against existing bindings using this value
        # We don't want this desired value to match against existing bindings, further down, so we clear it now to None 
        swuniVlan = None
    debug("swuniVlan = {}".format(swuniVlan))

    # Pre-checks before entering config mode
    cvlanAutoSensePortsList = []

    if cvlanPortList or cvlanMltList or cvlanAloneCreate:
        if 'get_vlan_configcontrol' in CLI_Dict[Family]:
            vlanCfgCtrl = sendCLI_showRegex(CLI_Dict[Family]['get_vlan_configcontrol'], 'vlanCfgCtrl')
        vlanExistName = sendCLI_showRegex(CLI_Dict[Family]['get_cvlan_name'].format(vlan), 'vlanExistName')
        if vlanExistName:
            if not vlanName and Family == 'Summit Series' and re.match(r'SYS_VLAN_', vlanExistName): # The VLAN already exists on the XOS but is a dynamic VLAN
                vlanName = 'L2VSN_VLAN_' + vlan
            vlanIsid = sendCLI_showRegex(CLI_Dict[Family]['get_cvlan_isid'].format(vlan), 'vlanIsid')
            if vlanIsid and vlanIsid != isid:
                exitError('VLAN {} is already assigned to I-SID {} which is different from requested I-SID {}'.format(vlan, vlanIsid, isid))
        if cvlanPortList:
            cvlanAutoSensePortsList = [x for x in cvlanPortList if autoSensePortDict and x in autoSensePortDict and autoSensePortDict[x] == 'Enable']
            debug("cvlanAutoSensePortsList = {}".format(cvlanAutoSensePortsList))
            if cvlanAutoSensePortsList:
                cvlanAutoSensePortsRange = generatePortRange(cvlanAutoSensePortsList)
                print "Selected ports where we need to disable auto-sense = {}".format(cvlanAutoSensePortsRange)
        if cvlanMltList: # VOSS only
            mltTaggingDict = sendCLI_showRegex(CLI_Dict[Family]['get_mlt_tagging'], 'mltTaggingDict')
            for mlt in cvlanMltList:
                if tagging == 'tag' and mltTaggingDict[mlt] == 'access':
                    exitError('MLT {} is configured as an access/untagged MLT, cannot "tag" VLAN {} on it'.format(mlt, vlan))
                if tagging == 'untag' and mltTaggingDict[mlt] == 'trunk':
                    exitError('MLT {} is configured as a trunk/tagged MLT, cannot "untag" VLAN {} on it'.format(mlt, vlan))


    if swuniPortList or swuniMltList or swuniAloneCreate:
        swuniPortsToConfigure = []
        swuniMltsToConfigure = []
        isidPorts = getIsidUniStruct(isid)
        debug("isidPorts = {}".format(isidPorts))

        if swuniPortList:
            swuniAutoSensePortsList = [x for x in swuniPortList if autoSensePortDict and x in autoSensePortDict and autoSensePortDict[x] == 'Enable']
            debug("swuniAutoSensePortsList = {}".format(swuniAutoSensePortsList))
            if swuniAutoSensePortsList:
                swuniAutoSensePortsRange = generatePortRange(swuniAutoSensePortsList)
                print "Selected ports where we need to disable auto-sense = {}".format(swuniAutoSensePortsRange)

            flexUniDisabledList = [x for x in flexUniPortDict if flexUniPortDict[x] == 'Disable']
            debug("flexUniDisabledList = {}".format(flexUniDisabledList))
            if flexUniDisabledList:
                flexUniEnablePortRange = generatePortRange(flexUniDisabledList)
                print "Selected ports where we need to enable flex-uni = {}".format(flexUniDisabledList)

            portsInIsidToRemove = [x for x in swuniPortList if x in isidPorts and isidPorts[x]['vlan'] != swuniVlan]
            debug("portsInIsidToRemove = {}".format(portsInIsidToRemove))
            if portsInIsidToRemove:
                print "Selected ports already configured in same I-SID but with wrong c-vid/tagging mode = {}".format(portsInIsidToRemove)

            # If one of the user selected ports happens to be already assigned to the I-SID and C-VID already, then we filter out these ports
            swuniPortsToConfigure = [x for x in swuniPortList if ( x not in isidPorts ) or ( x in isidPorts and isidPorts[x]['vlan'] != swuniVlan )]
            debug("swuniPortsToConfigure = {}".format(swuniPortsToConfigure))

        if swuniMltList:
            flexMltUniDisabledList = [x for x in flexUniMltDict if x in swuniMltList and flexUniMltDict[x] == 'disable']
            debug("flexMltUniDisabledList = {}".format(flexMltUniDisabledList))
            if flexMltUniDisabledList:
                print "MLT ids where we need to enable flex-uni = {}".format(flexMltUniDisabledList)
            mltsInIsidToRemove = [x for x in swuniMltList if x in isidPorts and isidPorts[x]['vlan'] != vlan]
            debug("mltsInIsidToRemove = {}".format(mltsInIsidToRemove))
            if mltsInIsidToRemove:
                print "MLTs selected already configured in same I-SID but with wrong c-vid/tagging mode = {}".format(mltsInIsidToRemove)

            # If one of the user selected ports happens to be already assigned to the I-SID and C-VID already, then we filter out these ports
            swuniMltsToConfigure = [x for x in swuniMltList if ( x not in isidPorts ) or ( x in isidPorts and isidPorts[x]['vlan'] != vlan )]
            debug("swuniMltsToConfigure = {}".format(swuniMltsToConfigure))

        if not swuniAloneCreate and not swuniPortsToConfigure and not swuniMltsToConfigure:
            if swuniPortList:
                print 'Ports {} are already assigned to I-SID {}'.format(swuniPortRange, isid)
            if swuniMltList:
                print 'MLT ids {} are already assigned to I-SID {}'.format(swuniMltList, isid)
            return # Not an error (service is already in place)

        # Update port &amp; MLTs to configure
        if swuniPortsToConfigure:
            swuniPortRange = generatePortRange(swuniPortsToConfigure)
            print "Effective ports we need to configure = {}".format(swuniPortRange)
        if swuniMltsToConfigure:
            print "Effective MLT ids we need to configure = {}".format(swuniMltsToConfigure)


    # Enter config mode now
    if 'config_context' in CLI_Dict[Family]:
        sendCLI_configCommand(CLI_Dict[Family]['config_context'])

    # CVLAN and Switched-UNI cases dealt separately
    if cvlanPortList or cvlanMltList or cvlanAloneCreate:
        if vlanCfgCtrl and vlanCfgCtrl != 'automatic':
            sendCLI_configCommand(CLI_Dict[Family]['set_vlan_configcontrol'].format('automatic'))
        if not vlanExistName:
            # Create CVLAN
            sendCLI_configCommand(CLI_Dict[Family]['create_cvlan'].format(vlan))
        if vlanName and (not vlanExistName or (vlanExistName and vlanName.lower() != vlanExistName.lower())): # XOS gives error if you try and configure same name on same VLAN
            sendCLI_configCommand(CLI_Dict[Family]['set_cvlan_name'].format(vlan, vlanName))
        if not vlanIsid:
            # Assign I-SID to CVLAN
            sendCLI_configCommand(CLI_Dict[Family]['set_cvlan_isid'].format(vlan, isid))

        if cvlanAutoSensePortsList:
            # Disable Auto-Sense
            sendCLI_configChain(CLI_Dict[Family]['disable_autosense'].format(cvlanAutoSensePortsRange))

        if cvlanPortList:
            # Assign ports to CVLAN
            sendCLI_configChain(CLI_Dict[Family]['create_cvlan_uni'][tagging].format(vlan, cvlanPortRange))

        if cvlanMltList: # VOSS only
            # Assign MLTs to CVLAN
            for mlt in cvlanMltList:
                sendCLI_configChain(CLI_Dict[Family]['create_cvlan_mlt_uni'].format(vlan, mlt))

        if vlanCfgCtrl and vlanCfgCtrl != 'automatic':
            sendCLI_configCommand(CLI_Dict[Family]['set_vlan_configcontrol'].format(vlanCfgCtrl))

    if swuniPortList or swuniMltList or swuniAloneCreate:
        if swuniPortList:
            if swuniAutoSensePortsList:
                # Disable Auto-Sense
                sendCLI_configChain(CLI_Dict[Family]['disable_autosense'].format(swuniAutoSensePortsRange))
                # Enable flex-uni on same ports, because disabling auto-sense has the effect of bumping flex-uni
                sendCLI_configChain(CLI_Dict[Family]['create_flex_uni'].format(swuniAutoSensePortsRange))

            if flexUniDisabledList:
                # Enable flex-uni on ports which are not already flex-uni enabled
                sendCLI_configChain(CLI_Dict[Family]['create_flex_uni'].format(flexUniEnablePortRange))
            if portsInIsidToRemove:
                for port in portsInIsidToRemove:
                    # Delete any of the selected ports which might happen to have already been configured in same I-SID but different c-vid
                    sendCLI_configChain(CLI_Dict[Family]['delete_switched_uni'][isidPorts[port]['type']].format(isid, isidPorts[port]['vlan'], port))

        if swuniMltList:
            if flexMltUniDisabledList:
                # Enable flex-uni on MLTs which are not already flex-uni enabled
                for mlt in flexMltUniDisabledList:
                    sendCLI_configChain(CLI_Dict[Family]['create_mlt_flex_uni'].format(mlt))
            if mltsInIsidToRemove:
                for mlt in mltsInIsidToRemove:
                    # Delete any of the selected MLT ids which might happen to have already been configured in same I-SID but different c-vid
                    sendCLI_configChain(CLI_Dict[Family]['delete_mlt_switched_uni'][isidPorts[mlt]['type']].format(isid, isidPorts[mlt]['vlan'], mlt))

        # Create/enter I-SID context
        sendCLI_configCommand(CLI_Dict[Family]['create_switched_isid_y'].format(isid), returnCliError=True)
        # We first configure the I-SID with trailing "\ny", in case the I-SID is already dynamically created, by EPT...
        # which would result in this confirmation prompt: WARNING:This i-sid is currently added with dynamic origin. By entering this context a CONFIGURED elan i-sid will also be created and will appear in any saved config. Do you want to continue (y/n) ? y
        if LastError: # If instead the I-SID was not already configured by EPT, we would not get the y/n prompt, and the "\ny" will result in an error message from the switch (hence returnCliError=True above)
            # So, only in that case (error from switch), we do the same command a 2nd time without the "\ny", just so that the command appears in printConfigSummary at the end
            sendCLI_configCommand(CLI_Dict[Family]['create_switched_isid'].format(isid))
        if swuniPortsToConfigure:
            # Assign ports to I-SID
            sendCLI_configCommand(CLI_Dict[Family]['create_switched_uni'][tagging].format(vlan, swuniPortRange))
        if swuniMltsToConfigure:
            # Assign MLT ids to I-SID
            for mlt in swuniMltsToConfigure:
                sendCLI_configCommand(CLI_Dict[Family]['create_mlt_switched_uni'][tagging].format(vlan, mlt))
        # Exit I-SID context
        sendCLI_configCommand(CLI_Dict[Family]['exit_config_context'])

    # Assign I-SID name, VOSS only
    if 'set_isid_name' in CLI_Dict[Family]:
        sendCLI_configCommand(CLI_Dict[Family]['set_isid_name'].format(isid, vlanName))

    # End and save config
    if 'end_config' in CLI_Dict[Family]:
        sendCLI_configCommand(CLI_Dict[Family]['end_config'])
    sendCLI_configCommand(CLI_Dict[Family]['save_config'])

    # Make XIQ-SE re-discover the switch
    rediscovery = nbiMutation(NBI_Query['rediscover_device'], IP=emc_vars['deviceIP'])

    # Make XIQ-SE reload the switch configuration
    if LooseVersion(emc_vars["serverVersion"]) &gt;= LooseVersion("23.2"): # This API call was added in XIQ-SE 23.2
        reload = nbiMutation(NBI_Query['reload_device'], IP=emc_vars['deviceIP'])
    else:
        reload = None
        print "Unable to initialte XIQ-SE config reload of device as this requires XIQ-SE version 23.2 or later; please perform manually"

    # Print summary of config performed
    printConfigSummary()

    # Print message about rediscovery outcome
    if rediscovery:
        print "Initiated XIQ-SE rediscovery of device"
    else:
        print "Failed to initialte XIQ-SE rediscovery of device; please perform manually"

    # Print message about config reload outcome
    if reload:
        print "Initiated XIQ-SE config reload of device"
    else:
        print "Failed to initialte XIQ-SE config reload of device; please perform manually"

main()
</content>
    <creationDate>1537273649994</creationDate>
    <creator>lstevens</creator>
    <defaultCategory></defaultCategory>
    <devicesRequired>true</devicesRequired>
    <encoded>true</encoded>
    <contexts>,Device,Groups,</contexts>
    <lastUpdateDate>1688472441059</lastUpdateDate>
    <lastUpdatedBy>lstevens</lastUpdatedBy>
    <miscXMLData></miscXMLData>
    <nosIds></nosIds>
    <postprocessScript></postprocessScript>
    <rollbackScript></rollbackScript>
    <saveConfigOnExit>false</saveConfigOnExit>
    <scriptOwner></scriptOwner>
    <scriptTimeout>60</scriptTimeout>
    <scriptType>Python</scriptType>
    <supprotedGroups></supprotedGroups>
    <roles>,XIQ-SE Administrator,</roles>
    <vendor></vendor>
    <version>0</version>
</script>

