<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<script name="Move to CLIP Mgmt IP">
    <abortOnError>true</abortOnError>
    <auditLogEnabled></auditLogEnabled>
    <category>,Provisioning,</category>
    <comments>Create mgmt clip IP on VSP and re-add to XMC with that new IP - v2.2</comments>
    <content>'''
This script is provided free of charge by Extreme. We hope such scripts are
helpful when used in conjunction with Extreme products and technology and can
be used as examples to modify and adapt for your ultimate requirements.
Extreme will not provide any official support for these scripts. If you do
have any questions or queries about any of these scripts you may post on
Extreme's community website "The Hub" (https://community.extremenetworks.com/)
under the scripting category.

ANY SCRIPTS PROVIDED BY EXTREME ARE HEREBY PROVIDED "AS IS", WITHOUT WARRANTY
OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL EXTREME OR ITS THIRD PARTY LICENSORS BE LIABLE FOR ANY CLAIM,
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE USE OR DISTRIBUTION OF SUCH
SCRIPTS.
'''

# --&gt; Insert here script description, version and metadata &lt;--

##########################################################
# XMC Script: Move Switch to CLIP mgmt IP                #
# Written by Ludovico Stevens, TME Extreme Networks      #
##########################################################

__version__ = '2.2'

# 1.0   - Initial
# 1.1   - Some extra IP validation checks
# 1.2   - Now works properly even in regular BEB (non-DVR Leaf) case
#       - For regular BEB, IP shortcuts is checked
#       - For regular BEB, non-GRT VRF L3VSN config is checked
#       - If a mgmt clip does not exist, the new one is created, and rollback performed if not reachable
# 1.3   - Deletion of mgmt vlan interface in DVR Leaf case can't be done, so we now just delete just the IP on it
# 1.4   - Can be run against multiple VSP switches
#       - Can re-name the VSP at the same time; both SNMP and ISIS sys-names are changed
#       - Decision whether to delete existing mgmt VLAN IP is configurable
#       - Only runs on VOSS 8.2 or later
# 1.5   - Option to delete existing mgmt VLAN IP was not working
#       - CLI session is now established to newly created CLIP IP within script, as check all good, after deleting/re-adding to XMC
#       - Deletion of existing mgmt VLAN IP is now done only if/once a CLI session can be established to new CLIP IP
#       - Switch config is now saved from CLI session on newly created CLIP IP
#       - When deleting the switch from NAC, now the switch is also deleted from any Location Groups too
# 1.6   - System Name input field was mandatory; now is optional
# 1.7   - Increased retries after re-adding switch to XMC/XIQ-SE to 20 from 10 (XIQ-SE is slower than XMC due to XIQ reporting)
# 1.8   - Updated with latest version of function libraries
#       - Able to re-try device addition into XIQ-SE; as sometimes the addition seems to fail
# 1.9   - Above change was not working; not easy to reproduce and thus test...
# 2.0   - Improvement to above logic
# 2.1   - Introduced a 5 sec wait before trying to re-connect to device after it is re-added to XIQ-SE
#       - Introduced 20sec wait between deleting device from XIQ-SE and re-adding it
#       - Renamed XMC to XIQ-SE
# 2.2   - Updated to latest modules and script template
#       - Implements CLI retries
#       - Added variable delayReConnect set now to 20sec (was previuosly hard coded 5sec)


'''
#@MetaDataStart
#@DetailDescriptionStart
#######################################################################################
# 
# Given one or more VSP switches already in XIQ-SE, this script will ask user to provide
# a clip IP and VRF which will then be configured as mgmt clip on the switch. If the
# switch already has a mgmt clip, the existing mgmt clip will be deleted and replaced
# with the new one. If the switch has a mgmt vlan IP, this can be deleted if the user
# selects to do so in the script input pull-down.
# Since the switch is effectively deleted and re-added to XIQ-SE, the script allows the
# switch sysname to be changed at the same time, which will automatically be reflected
# once the switch is re-added to XIQ-SE. Furthermore, the sysname change is perfomed not
# only on the snmp-server name (prompt), but also for the ISIS sys-name.
# Before attempting to change the IP on the switch, the script will first of all make
# sure that the new IP address provided is not already known by XIQ-SE and that it does
# not exist on the network (does not reply to ping).
# On a regular BEB (not a DVR Leaf) if the new mgmt clip is on GRT, IP Shortcuts will
# also get automatically enabled if not already enabled. However no ISIS source-address
# will be set.
# Checks are made to ensure that if the VRF provided is non-GRT on a regular BEB, that
# the VRF already has L3VSN enabled (which in turn implies that IP Shortcuts is enabled)
# Otherwise the script will error and make no changes. Likewise, on a DVR Leaf, the
# script will only accept to create a mgmt clip in GRT, and will error otherwise.
#
# If a mgmt clip does not already exist, the script takes a safe approach by creating
# the new mgmt clip and making sure that this is reachable by XIQ-SE before proceeding
# any further. If the newly created mgmt clip is not reachable after 10 seconds, the
# changes are rolled back and the script will error.
# But if a mgmt clip does already exist, then the only way to change it is to go
# ahead and delete it and create the new mgmt clip IP; but in this case, if the new IP
# is not reachable after the change, then the switch will be lost.
# Once the new clip mgmt IP is set, the switch is deleted from XIQ-SE's database as well
# as XIQ-SE Control if there, and also from any NAC Location Groups. It is then re-added
# to the same site, with the same admin profile, with the newly configured clip mgmt
# IP mgmt address.
# The script then waits a further 10 seconds, before attempting to open a session on
# the new clip IP. This session is used to delete the existing mgmt VLAN IP, if user
# had selected the 'delete' pull-down, and to save the config on the switch. 
#
#######################################################################################
#@DetailDescriptionEnd
# ( = &amp;#40;
# ) = &amp;#41;
# , = &amp;#44;
# &lt; = &amp;lt;
# &gt; = &amp;gt;
#@SectionStart (description = "New switch mgmt circuitless IP &amp;#40;mask will be 32bits&amp;#41;")
#    @VariableFieldLabel (
#        description = "Associated VRF name &amp;#40;default is GRT&amp;#41;",
#        type = string,
#        required = no,
#        name = "userInput_vrf",
#        value = "GlobalRouter",
#    )
#    @VariableFieldLabel (
#        description = "Existing mgmt VLAN IP",
#        type = string,
#        required = no,
#        readOnly = no,
#        validValues = [Delete, Do NOT delete],
#        value = "Delete"
#        name = "userInput_mgmtVlanIp",
#    )
#    @VariableFieldLabel (
#        description = "Mgmt CLIP IP",
#        type = string,
#        required = yes,
#        name = "userInput_ip",
#        scope = device
#    )
#    @VariableFieldLabel (
#        description = "System Name",
#        type = string,
#        required = no,
#        name = "userInput_sysname",
#        scope = device
#    )
#@SectionEnd
#@SectionStart (description = "Sanity / Debug")
#    @VariableFieldLabel (
#        description = "Sanity: enable if you do not trust this script and wish to first see what it does. In sanity mode config commands are not executed",
#        type = string,
#        required = no,
#        validValues = [Enable, Disable],
#        name = "userInput_sanity",
#    )
#    @VariableFieldLabel (
#        description = "Debug: enable if you need to report a problem to the script author",
#        type = string,
#        required = no,
#        validValues = [Enable, Disable],
#        name = "userInput_debug",
#    )
#@SectionEnd
#@MetaDataEnd
'''


#
# Variables:
#
Debug = False    # Enables debug messages
Sanity = False   # If enabled, config commands are not sent to host (show commands are operational)
Family = 'VSP Series';
cliRetries           = 6
cliRetryDelay        = 10
delaySiteReAdd       = 20
delayReConnect       = 20


CLI_Dict = {
    'VSP Series': {
        'disable_more_paging'        : 'terminal more disable',
        'enable_context'             : 'enable',
        'config_context'             : 'config term',
        'end_config'                 : 'end',
        'get_mgmt_ip_mask'           : 'int://show mgmt ip||{}\/(\d\d?) ', # IP address
        'get_dvr_type'               : 'str-lower://show dvr||^Role\s+:\s+(Leaf|Controller)',
        'check_vrf_exists'           : 'bool://show ip vrf||^{} ', # VRF name
        'check_vrf_l3vsn'            : 'bool://show ip ipvpn vrf {0}||^{0} +\d+ +enabled', # VRF name
        'list_mgmt_interfaces'       : 'list://show mgmt interface||^\d +\S+ +([A-Z]+) ',
        'list_mgmt_ips'              : 'dict://show mgmt ip||^\d +(\S+) +(\d+\.\d+\.\d+\.\d+)/\d',
        'delete_mgmt_clip'           : 'no mgmt clip',
        'delete_mgmt_vlan'           : 'no mgmt vlan',
        'delete_mgmt_vlan_dvr_leaf'  : 'mgmt vlan; no ip address {}; exit', # IP address
        'enable_ip_shortcuts'        : 'router isis; spbm 1 ip enable; exit',
        'disable_ip_shortcuts'       : 'router isis; no spbm 1 ip enable; exit',
        'create_mgmt_clip'           : # VRF name, IP address
                                       '''
                                       mgmt clip vrf {0}
                                          ip address {1}/32
                                          enable
                                       exit
                                       ''',
        'change_sys_name'            : # Sys-name
                                       '''
                                       snmp-server name {0}
                                       router isis
                                          sys-name {0}
                                       exit
                                       ''',
    },
}

NBI_Query = { # GraphQl query / NBI_Query['key'].replace('&lt;IP&gt;', var)
    'nbiAccess': {
        'json': '''
                {
                  administration {
                    serverInfo {
                      version
                    }
                  }
                }
                ''',  
        'key': 'version'
    },
    'checkSwitchXmcDb': {
        'json': '''
                {
                  network {
                    device(ip:"&lt;IP&gt;") {
                      id
                    }
                  }
                }
                ''',
        'key': 'device'
    },
    'getSitePath': {
        'json': '''
                {
                  network {
                    device(ip: "&lt;IP&gt;") {
                      sitePath
                    }
                  }
                }
                ''',
        'key': 'sitePath'
    },
    'getDeviceAdminProfile': {
        'json': '''
                {
                  network {
                    device(ip:"&lt;IP&gt;") {
                      deviceData {
                        profileName
                      }
                    }
                  }
                }
                ''',
        'key': 'profileName'
    },
    'delete_device': {
        'json': '''
                mutation {
                  network {
                    deleteDevices(input:{
                      removeData: true
                      devices: {
                        ipAddress:"&lt;IP&gt;"
                      }
                    }) {
                      status
                      message
                    }
                  }
                }
                ''',
    },
    'checkSwitchNacConfig': {
        'json': '''
                {
                  accessControl {
                    switch(ipAddress: "&lt;IP&gt;") {
                      ipAddress
                    }
                  }
                }
                ''',
        'key': 'switch'
    },
    'getNacLocationGroups': {
        'json': '''
                {
                  accessControl {
                    groupNamesByType(typeString: "LOCATION")
                  }
                }
                ''',
        'key': 'groupNamesByType'
    },
    'accessControlDeleteSwitch': {
        'json': '''
                mutation {
                  accessControl {
                    deleteSwitch(input: {
                      searchKey: "&lt;IP&gt;"
                    }) {
                      message
                      status
                    }
                  }
                }
                ''',
    },
    'accessControlRemoveSwitchFromLocation': {
        'json': '''
                mutation {
                  accessControl {
                    removeEntryFromGroup(input: {
                      group: "&lt;LOCATIONGROUP&gt;"
                      value: "&lt;IP&gt;"
                    }) {
                      message
                      status
                    }
                  }
                }
                ''',
    },
    'create_device': {
        'json': '''
                mutation {
                  network {
                    createDevices(input:{
                      devices: {
                        ipAddress:"&lt;IP&gt;"
                        siteLocation:"&lt;SITE&gt;"
                        profileName:"&lt;PROFILE&gt;"
                      }
                    }) {
                      status
                      message
                    }
                  }
                }
                ''',
    },
    'check_device': {
        'json': '''
                {
                  network {
                    device(ip: "&lt;IP&gt;") {
                      down
                    }
                  }
                }
                ''',
        'key': 'device'
    },
}




#
# Base functions
# base.py v12
#
import re                           # Used by scriptName
import time                         # Used by debug &amp; exitError
ExitErrorSleep = 10
DebugLogger = None

def printLog(message): # v1 - Print message to stdout but also into debug log file
    if DebugLogger:
        DebugLogger.info(message)
    else:
        print message

def debug(debugOutput): # v4 - Use function to include debugging in script; set above Debug variable to True or False to turn on or off debugging
    if not Debug:
        return
    if DebugLogger:
        DebugLogger.debug(debugOutput)
    else:
        print u"[{}] {}".format(time.ctime(), debugOutput) # Might be unicode

def exitError(errorOutput, sleep=ExitErrorSleep): # v3 - Exit script with error message and setting status appropriately
    if 'workflowMessage' in emc_vars: # Workflow
        time.sleep(sleep) # When workflow run on multiple devices, want ones that error to be last to complete, so THEY set the workflow message
        emc_results.put("deviceMessage", errorOutput)
        emc_results.put("activityMessage", errorOutput)
        emc_results.put("workflowMessage", errorOutput)
    emc_results.setStatus(emc_results.Status.ERROR)
    raise RuntimeError(errorOutput)

def abortError(cmd, errorOutput): # v2 - A CLI command failed, before bombing out send any rollback commands which may have been set
    printLog("Aborting script due to error on previous command")
    try:
        rollbackStack()
    finally:
        printLog("Aborting because this command failed: {}".format(cmd))
        exitError(errorOutput)

def scriptName(): # v1 - Returns the assigned name of the Script or Workflow
    name = None
    if 'workflowName' in emc_vars: # Workflow
        name = emc_vars['workflowName']
    elif 'javax.script.filename' in emc_vars: # Script
        nameMatch = re.search(r'\/([^\/\.]+)\.py$', emc_vars['javax.script.filename'])
        name = nameMatch.group(1) if nameMatch else None
    return name

def workflow_DeviceMessage(msg): # v1 - Set workflow messages appropriately; '&lt;&gt;' is replaced with device IP or list
    singleDeviceMsg = manyDevicesMsg = msg
    if '&lt;&gt;' in msg:
        devicesListStr = emc_vars['devices'][1:-1]
        singleDeviceMsg = msg.replace('&lt;&gt;', emc_vars['deviceIP']).replace('(s)', '').replace('(es)', '')
        if len(devicesListStr.split(',')) &gt; 1:
            manyDevicesMsg = msg.replace('&lt;&gt;', devicesListStr).replace('(s)', 's').replace('(es)', 'es')
        else:
            manyDevicesMsg = singleDeviceMsg
    emc_results.put("deviceMessage", singleDeviceMsg)
    emc_results.put("activityMessage", manyDevicesMsg)
    emc_results.put("workflowMessage", manyDevicesMsg)


#
# CLI/SNMP Rollback functions
# rollback.py v5
#
RollbackStack = [] # Format [ ['cli', &lt;command&gt;], ['snmp', [requestDict, instance, oldValue], ...]]

def rollbackStack(): # v3 - Execute all commands on the rollback stack
    if RollbackStack:
        printLog("\nApplying rollback commands to undo partial config and return device to initial state")
        while RollbackStack:
            cfgType, data = RollbackStack.pop()
            if cfgType == 'cli':
                sendCLI_configChain(data, returnCliError=True)
            elif cfgType == 'snmp':
                snmpSet(data[0], instance=data[1], value=data[2], returnError=True)
            else:
                printLog("Invalid rollback stack data entry: {}".format(cfgType))

def rollbackCommand(cmd): # v3 - Add a command to the rollback stack; these commands will get popped and executed should we need to abort
    global RollbackStack
    RollbackStack.append(['cli', cmd])
    cmdList = map(str.strip, re.split(r'[;\n]', cmd)) # cmd could be a configChain
    cmdList = [x for x in cmdList if x] # Weed out empty elements 
    cmdOneLiner = " / ".join(cmdList)
    printLog("Pushing onto rollback stack CLI: {}\n".format(cmdOneLiner))

def rollbackSnmp(requestDict, instance, oldValue): # v2 - Add SNMP request to rollback stack
    # These commands will get popped and executed as snmpSet should we need to abort
    global RollbackStack
    RollbackStack.append(['snmp', [requestDict, instance, oldValue]])
    oidList, instList, _, valueList = snmpInputLists("rollbackSnmp", requestDict, instance, oldValue)
    printLog("Pushing onto rollback stack SNMP:")
    for inOid, inst, currVal in zip(oidList, instList, valueList):
        displayOid, oid = separateOid(inOid)
        setOid = '.'.join([oid, str(inst)]) if inst != None else oid
        printLog(" - {}{} revert to {}".format(displayOid, setOid, currVal))

def rollBackPop(number=0): # v2 - Remove entries from RollbackStack
    global RollbackStack
    if number == 0:
        RollbackStack = []
        printLog("Rollback stack emptied")
    else:
        del RollbackStack[-number:]
        printLog("Rollback stack popped last {} entries".format(number))


#
# CLI functions - (use of rollback requires rollback.py)
# cli.py v32
#
import re
import time                         # Used by sendCLI_configChain &amp; sendCLI_configChain2 with 'sleep' &amp; 'block directives
RegexPrompt = re.compile('.*[\?\$%#&gt;]\s?$')
RegexError  = re.compile(
    '^%|\x07|error|invalid|cannot|unable|bad|not found|not exist|not allowed|no such|out of range|incomplete|failed|denied|can\'t|ambiguous|do not|unrecognized',
    re.IGNORECASE | re.MULTILINE
)
RegexNoError  = re.compile( # Messages which would be false positives for an error condition, when they are just a warning..
    '(?:'
    + 'Both ends of MACsec link cannot have the same key-parity value'
    + '|% Saving \d+ bytes to flash:startup-config' # ISW: copy running-config startup-config
    + ')',
    re.IGNORECASE | re.MULTILINE
)
RegexContextPatterns = { # Ported from acli.pl
    'ERS Series' : [
        re.compile('^(?:interface |router \w+$|route-map (?:\"[\w\d\s\.\+-]+\"|[\w\d\.-]+) \d+$|ip igmp profile \d+$|wireless|application|ipv6 dhcp guard policy |ipv6 nd raguard policy )'), # level0
        re.compile('^(?:security|crypto|ap-profile |captive-portal |network-profile |radio-profile )'), # level1
        re.compile('^(?:locale)'), # level2
    ],
    'VSP Series' : [
        re.compile('^ *(?:interface |router \w+$|router vrf|route-map (?:\"[\w\d\s\.\+-]+\"|[\w\d\.-]+) \d+$|application|i-sid \d+|wireless|logical-intf isis \d+|mgmt (?:\d|clip|vlan|oob)|ovsdb$)'), # level0
        re.compile('^ *(?:route-map (?:\"[\w\d\s\.\+-]+\"|[\w\d\.-]+) \d+$)'), # level1
    ],
    'ISW-Series' : [
        re.compile('^ *(?:ringv2-group |interface )'), # level0
    ],
    'ISW-Series-Marvell' : [
        re.compile('^ *(?:ringv2-group |interface )'), # level0
    ],
}
RegexExitInstance = re.compile('^ *(?:exit|back|end|config|save)(?:\s|$)')
RegexEmbeddedErrMode = re.compile('^#error +(fail|stop|continue) *$')
RegexEmbeddedSleep = re.compile('^#sleep  +(\d+) *$')
RegexEmbeddedWarpBlock = re.compile('^#block +(start|execute)(?:(?: +(wait|reconnect))? +(\d+))? *$')
Indent = 3 # Number of space characters for each indentation
LastError = None
LastPrompt = ''
ConfigHistory = []

def cliError(outputStr): # v1 - Check command output for CLI error message
    if not RegexNoError.search(outputStr) and RegexError.search(outputStr):
        return True
    else:
        return False

def cleanOutput(outputStr): # v6 - Remove echoed command and final prompt from output
    if re.match(r'Error:', outputStr): # Case where emc_cli.send timesout: "Error: session exceeded timeout: 30 secs"
        return outputStr
    outputLines = outputStr.splitlines()
    lastLine = outputLines[-1]
    if RegexPrompt.match(lastLine):
        global LastPrompt
        LastPrompt = lastLine
        return '\n'.join(outputLines[1:-1])
    else:
        return '\n'.join(outputLines[1:])

def configChain(chainStr): # v3 - Produces a list of a set of concatenated commands (either with ';' or newlines)
    chainStr = re.sub(r'\n(\w)(\x0d?\n|\s*;|$)', chr(0) + r'\1\2', chainStr) # Mask trailing "\ny" or "\nn" on commands before making list
    # Checking for \x0d? is necessary when DOS text files are transferred to XIQ-SE, and read and processed locally..
    chainStr = re.sub(r'(\".*?\")', lambda m: m.group(1).replace(';', chr(ord(";")|128)), chainStr) # Mask ";" inside double quotes section
    cmdList = map(str.strip, re.split(r'[;\n]', chainStr))
    cmdList = filter(None, cmdList) # Filter out empty lines, if any
    cmdList = [x.replace(chr(ord(";")|128), ';') for x in cmdList] # Unmask after list made
    cmdList = [re.sub(r'\x00(\w)(\x0d?\n|$)', r'\n\1\2', x) for x in cmdList] # Unmask after list made
    return cmdList

def parseRegexInput(cmdRegexStr): # v1 - Parses input command regex for both sendCLI_showRegex() and xmcLinuxCommand()
    # cmdRegexStr format: &lt;type&gt;://&lt;cli-show-command&gt; [&amp; &lt;additional-show-cmd&gt;]||&lt;regex-to-capture-with&gt;
    if re.match(r'\w+(?:-\w+)?://', cmdRegexStr):
        mode, cmdRegexStr = map(str.strip, cmdRegexStr.split('://', 1))
    else:
        mode = None
    cmd, regex = map(str.strip, cmdRegexStr.split('||', 1))
    cmdList = map(str.strip, cmd.split('&amp;'))
    return mode, cmdList, regex

def formatOutputData(data, mode): # v3 - Formats output data for both sendCLI_showRegex() and xmcLinuxCommand()
    if not mode                 : value = data                                   # Legacy behaviour same as list
    elif mode == 'bool'         : value = bool(data)                             # No regex capturing brackets required
    elif mode == 'str'          : value = str(data[0]) if data else None         # Regex should have 1 capturing bracket at most
    elif mode == 'str-lower'    : value = str(data[0]).lower() if data else None # Same as str but string made all lowercase
    elif mode == 'str-upper'    : value = str(data[0]).upper() if data else None # Same as str but string made all uppercase
    elif mode == 'str-join'     : value = ''.join(data)                          # Regex with max 1 capturing bracket, joins list to string
    elif mode == 'str-nwlnjoin' : value = "\n".join(data)                        # Regex with max 1 capturing bracket, joins list to multi-line string
    elif mode == 'int'          : value = int(data[0]) if data else None         # Regex must have 1 capturing bracket at most
    elif mode == 'list'         : value = data                                   # If &gt; 1 capturing brackets, will be list of tuples
    elif mode == 'list-reverse' : value = list(reversed(data))                   # Same as list but in reverse order
    elif mode == 'list-diagonal': value = [data[x][x] for x in range(len(data))] # Regex pat1|pat2 = list of tuples; want [0][0],[1][1],etc
    elif mode == 'tuple'        : value = data[0] if data else ()                # Regex &gt; 1 capturing brackets on same line, returns 1st tuple
    elif mode == 'dict'         : value = dict(data)                             # Regex must have 2 capturing brackets exactly
    elif mode == 'dict-reverse' : value = dict(map(reversed, data))              # Same as dict, but key/values will be flipped
    elif mode == 'dict-both'    : value = dict(data), dict(map(reversed, data))  # Returns 2 dict: dict + dict-reverse
    elif mode == 'dict-diagonal': value = dict((data[x][x*2],data[x][x*2+1]) for x in range(len(data))) # {[0][0]:[0][1], [1][2]:[1][3], etc}
    elif mode == 'dict-sequence': value = dict((data[x*2][0],data[x*2+1][1]) for x in range(len(data)/2)) # {[0][0]:[1][1], [2][0]:[3][1], etc}
    else:
        RuntimeError("formatOutputData: invalid scheme type '{}'".format(mode))
    return value

def sendCLI_showCommand(cmd, returnCliError=False, msgOnError=None, retries=0, retryDelay=0): # v4 - Send a CLI show command; return output
    global LastError
    if retries and retryDelay: # To be used on very first CLI command sent to device
        while retries &gt;= 0:
            resultObj = emc_cli.send(cmd)
            # If it fails to connect, the following is automatically printed to the session: "Failed to connect to &lt;IP-address&gt;"
            emc_results.setStatus(emc_results.Status.STARTED) # Clears failed status on XIQ-SE script/workflow activity
            if resultObj.isSuccess():
                retries = -1 # All good, come out of while loop
            else:
                printLog("Retrying in {} seconds".format(retryDelay))
                time.sleep(retryDelay)
                retries -= 1
    else:
        resultObj = emc_cli.send(cmd)
    if resultObj.isSuccess():
        outputStr = cleanOutput(resultObj.getOutput())
        if outputStr and cliError("\n".join(outputStr.split("\n")[:4])): # If there is output, check for error in 1st 4 lines only (timestamp banner might shift it by 3 lines)
            if returnCliError: # If we asked to return upon CLI error, then the error message will be held in LastError
                LastError = outputStr
                if msgOnError:
                    printLog("==&gt; Ignoring above error: {}\n\n".format(msgOnError))
                return None
            abortError(cmd, outputStr)
        LastError = None
        return outputStr
    else:
        exitError(resultObj.getError())

def sendCLI_showRegex(cmdRegexStr, debugKey=None, returnCliError=False, msgOnError=None): # v1 - Send show command and extract values from output using regex
    # Regex is by default case-sensitive; for case-insensitive include (?i) at beginning of regex on input string
    mode, cmdList, regex = parseRegexInput(cmdRegexStr)
    for cmd in cmdList:
        # If cmdList we try each command in turn until one works; we don't want to bomb out on cmds before the last one in the list
        ignoreCliError = True if len(cmdList) &gt; 1 and cmd != cmdList[-1] else returnCliError
        outputStr = sendCLI_showCommand(cmd, ignoreCliError, msgOnError)
        if outputStr:
            break
    if not outputStr: # returnCliError true
        return None
    data = re.findall(regex, outputStr, re.MULTILINE)
    debug("sendCLI_showRegex() raw data = {}".format(data))
    # Format we return data in depends on what '&lt;type&gt;://' was pre-pended to the cmd &amp; regex
    value = formatOutputData(data, mode)
    if Debug:
        if debugKey: debug("{} = {}".format(debugKey, value))
        else: debug("sendCLI_showRegex OUT = {}".format(value))
    return value

def sendCLI_configCommand(cmd, returnCliError=False, msgOnError=None, waitForPrompt=True, historyAppend=True): # v6 - Send a CLI config command
    global LastError
    cmd = re.sub(r':\/\/', ':' + chr(0) + chr(0), cmd) # Mask any https:// type string
    cmd = re.sub(r' *\/\/ *', r'\n', cmd) # Convert "//" to "\n" for embedded // passwords
    cmd = re.sub(r':\x00\x00', r'://', cmd) # Unmask after // replacemt
    cmdStore = re.sub(r'\n.+$', '', cmd, flags=re.DOTALL) # Strip added "\n"+[yn] or // passwords
    if Sanity:
        printLog("SANITY&gt; {}".format(cmd))
        if historyAppend:
            ConfigHistory.append(cmdStore)
        LastError = None
        return True
    resultObj = emc_cli.send(cmd, waitForPrompt)
    if resultObj.isSuccess():
        outputStr = cleanOutput(resultObj.getOutput())
        if outputStr and cliError("\n".join(outputStr.split("\n")[:4])): # If there is output, check for error in 1st 4 lines only
            if returnCliError: # If we asked to return upon CLI error, then the error message will be held in LastError
                LastError = outputStr
                if msgOnError:
                    printLog("==&gt; Ignoring above error: {}\n\n".format(msgOnError))
                return False
            abortError(cmd, outputStr)
        if historyAppend:
            ConfigHistory.append(cmdStore)
        LastError = None
        return True
    else:
        exitError(resultObj.getError())

def sendCLI_configChain(chainStr, returnCliError=False, msgOnError=None, waitForPrompt=True, historyAppend=True, abortOnError=True): # v6 - Send a list of config commands
    # Syntax: chainStr can be a multi-line string where individual commands are on new lines or separated by the semi-colon ";" character
    # Some embedded directive commands are allowed, these must always begin with the hash "#" character:
    # #error fail       : If a subsequent command generates an error, make the entire script fail
    # #error stop       : If a subsequent command generates an error, do not fail the script but stop processing firther commands
    # #error continue   : If a subsequent command generates an error, ignore it and continue executing remaining commands
    # #sleep &lt;secs&gt;     : Sleep for specified seconds
    cmdList = configChain(chainStr)

    # Check if last command is a directive, as we have special processing for the last line and don't want directives there
    while RegexEmbeddedWarpBlock.match(cmdList[-1]) or RegexEmbeddedErrMode.match(cmdList[-1]) or RegexEmbeddedSleep.match(cmdList[-1]):
        cmdList.pop() # We just pop it off, they serve no purpose as last line anyway

    successStatus = True
    for cmd in cmdList[:-1]: # All but last
        embeddedErrMode = RegexEmbeddedErrMode.match(cmd)
        embeddedSleep = RegexEmbeddedSleep.match(cmd)
        if embeddedErrMode:
            errorMode = embeddedErrMode.group(1)
            returnCliError = False if errorMode == 'fail' else True
            abortOnError = True if errorMode == 'stop' else False
            continue # After setting the above, we skip the embedded command
        elif embeddedSleep:
            time.sleep(embeddedSleep.group(1))
            continue # Next command
        success = sendCLI_configCommand(cmd, returnCliError, msgOnError, historyAppend=historyAppend)
        if not success:
            successStatus = False
            if abortOnError:
                return False
    # Last now
    success = sendCLI_configCommand(cmdList[-1], returnCliError, msgOnError, waitForPrompt, historyAppend)
    if not success:
        return False
    return successStatus

def printConfigSummary(): # v5 - Print summary of all config commands executed with context indentation
    global ConfigHistory
    emc_cli.close()
    if not len(ConfigHistory):
        printLog("No configuration was performed")
        return
    printLog("The following configuration was successfully performed on switch:")
    indent = ''
    level = 0
    if Family in RegexContextPatterns:
        maxLevel = len(RegexContextPatterns[Family])
    for cmd in ConfigHistory:
        if Family in RegexContextPatterns:
            if level &lt; maxLevel and RegexContextPatterns[Family][level].match(cmd):
                printLog("-&gt; {}{}".format(indent, cmd))
                level += 1
                indent = ' ' * Indent * level
                continue
            elif RegexExitInstance.match(cmd):
                if level &gt; 0:
                    level -= 1
                indent = ' ' * Indent * level
        printLog("-&gt; {}{}".format(indent, cmd))
    ConfigHistory = []


#
# CLI warp buffer functions (requires cli.py v26)
# cliWarp.py v12
#
import os                           # Used by warpBuffer_execute
WarpBuffer = []

def warpBuffer_add(chainStr): # v1 - Preload WarpBuffer with config or configChains; buffer can then be executed with warpBuffer_execute()
    global WarpBuffer
    cmdList = configChain(chainStr)
    for cmd in cmdList:
        cmdAdd = re.sub(r'\n.+$', '', cmd) # Strip added CR+y or similar (these are not required when sourcing from file on VOSS and do not work on ERS anyway)
        WarpBuffer.append(cmdAdd)

def warpBuffer_execute(chainStr=None, returnCliError=False, msgOnError=None, waitForPrompt=True, historyAppend=True): # v11 - Appends to existing WarpBuffer and then executes it
    # Same as sendCLI_configChain() but all commands are placed in a script file on the switch and then sourced there
    # Apart from being fast, this approach can be used to make config changes which would otherwise result in the switch becomming unreachable
    # Use of this function assumes that the connected device (VSP) is already in privExec + config mode
    global WarpBuffer
    global LastError
    xmcTftpRoot = '/tftpboot'
    xmcServerIP = emc_vars["serverIP"]
    switchIP = emc_vars["deviceIP"]
    userName = emc_vars["userName"].replace('.', '_').replace('@', '_')
    tftpCheck = {
        #'VSP Series':    'bool://show boot config flags||^flags tftpd true',
        'VSP Series':    True, # Always enabled as Client,
        'Summit Series': 'bool://show process tftpd||Ready',
        'ERS Series':    True, # Always enabled
    }
    tftpActivate = {
        #'VSP Series':    'boot config flags tftpd',
        'Summit Series': 'start process tftpd',
    }
    tftpDeactivate = {
        'VSP Series':    'no boot config flags tftpd',
        'Summit Series': 'terminate process tftpd graceful',
    }
    tftpExecute = { # XMC server IP (TFTP server), Script file to fetch and execute
        'VSP Series':    'copy "{0}:{1}" /intflash/.script.src -y; more .script.src; source .script.src debug',
        'Summit Series': 'tftp get {0} "{1}" .script.xsf; cat .script.xsf; run script .script.xsf',
        'ERS Series':    'configure network address {0} filename "{1}"',
    }

    if chainStr:
        warpBuffer_add(chainStr)
    if Family not in tftpCheck:
        exitError('Sourcing commands via TFTP only supported in family types: {}'.format(", ".join(list(tftpCheck.keys()))))

    # Determine whether switch can do TFTP
    if tftpCheck[Family] == True:
        tftpEnabled = True
    else:
        tftpEnabled = sendCLI_showRegex(tftpCheck[Family], returnCliError=True)
        if tftpEnabled == None: # Case of X435 which does not have configurable TFTP process, but TFTP is there
            tftpEnabled = True
    if not tftpEnabled:
        if Sanity:
            printLog("SANITY&gt; {}".format(tftpActivate[Family]))
            if historyAppend:
                ConfigHistory.append(tftpActivate[Family])
        else:
            sendCLI_configCommand(tftpActivate[Family], returnCliError, msgOnError, historyAppend=historyAppend) # Activate TFTP now
        warpBuffer_add(tftpDeactivate[Family])      # Restore TFTP state on completion

    if Sanity:
        for cmd in WarpBuffer:
            printLog("SANITY(warp)&gt; {}".format(cmd))
            if historyAppend:
                ConfigHistory.append(cmd)
        LastError = None
        return True

    # Write the commands to a file under XMC's TFTP root directory
    tftpFileName = (userName + '.' + scriptName()).replace(' ', '_') + '.' + switchIP.replace('.', '_')
    tftpFilePath = xmcTftpRoot + '/' + tftpFileName
    try:
        with open(tftpFilePath, 'w') as f:
            if Family == 'VSP Series': # Always add these 2 lines, as VSP source command does not inherit current context
                f.write("enable\n")
                f.write("config term\n")
            for cmd in WarpBuffer:
                f.write(cmd + "\n")
            f.write("\n") # Make sure we have an empty line at the end, or VSP sourcing won't process last line...
            debug("warpBuffer - write of TFTP config file : {}".format(tftpFilePath))
    except Exception as e: # Expect IOError
        printLog("{}: {}".format(type(e).__name__, str(e)))
        exitError("Unable to write to TFTP file '{}'".format(tftpFilePath))

    # Make the switch fetch the file and execute it
    success = sendCLI_configChain(tftpExecute[Family].format(xmcServerIP, tftpFileName), returnCliError, msgOnError, waitForPrompt, historyAppend=False)
    # Clean up by deleting the file from XMC TFTP directory
    os.remove(tftpFilePath)
    debug("warpBuffer - delete of TFTP config file : {}".format(tftpFilePath))

    if not success: # In this case some commands might have executed, before the error; these won't be captured in ConfigHistory
        WarpBuffer = []
        return False
    if historyAppend:
        ConfigHistory.extend(WarpBuffer)
    WarpBuffer = []
    LastError = None
    return True


#
# XMC GraphQl &amp; RESTCONF &amp; XIQ API required functions
# apiBase.py v7
#
from java.util import LinkedHashMap
HTTP_RESONSE_OK = {
    'GET':      [200],
    'PUT':      [200,201],
    'POST':     [201],
    'PATCH':    [200],
    'DELETE':   [200,204],
}

def recursionKeySearch(nestedDict, returnKey): # v2 - Used by both nbiQuery() and nbiMutation() and restconfCall()
    for key, value in nestedDict.iteritems():
        if key == returnKey:
            return True, value
    for key, value in nestedDict.iteritems():
        if isinstance(value, (dict, LinkedHashMap)): # XMC Python is Jython where a dict is in fact a java.util.LinkedHashMap
            foundKey, foundValue = recursionKeySearch(value, returnKey)
            if foundKey:
                return True, foundValue
    return [None, None] # If we find nothing

def recursionStatusSearch(nestedDict): # v4 - Used by nbiMutation(), seeks the status key and returned message
    for key, value in nestedDict.iteritems():
        if key == 'status':
            if 'message' in nestedDict and nestedDict['message']:
                return True, value, nestedDict['message']
            elif 'result' in nestedDict and nestedDict['result'] and 'msg' in nestedDict['result']: # For Policy mutations..
                return True, value, nestedDict['result']['msg']
            else:
                return True, value, None
    for key, value in nestedDict.iteritems():
        if isinstance(value, (dict, LinkedHashMap)): # XMC Python is Jython where a dict is in fact a java.util.LinkedHashMap
            foundKey, foundValue, foundMsg = recursionStatusSearch(value)
            if foundKey:
                return True, foundValue, foundMsg
    return [None, None, None] # If we find nothing

def replaceKwargs(queryString, kwargs): # v2 - Used by both nbiQuery() and nbiMutation() and restconfCall()
    for key in kwargs:
        if type(kwargs[key]) == bool:
            replaceValue = str(kwargs[key]).lower()
        elif type(kwargs[key]) == unicode:
            replaceValue = kwargs[key] # Keep as is
        else:
            replaceValue = str(kwargs[key]) # Make string
        queryString = queryString.replace('&lt;'+key+'&gt;', replaceValue)
    return queryString # Note, might return unicode


#
# XMC GraphQl NBI functions - (requires apiBase.py)
# apiXmc.py v16
#
LastNbiError = None
NbiUrl = None

def nbiQuery(jsonQueryDict, debugKey=None, returnKeyError=False, **kwargs): # v8 - Makes a GraphQl query of XMC NBI; if returnKey provided returns that key value, else return whole response
    global LastNbiError
    jsonQuery = replaceKwargs(jsonQueryDict['json'], kwargs) # Might be unicode
    returnKey = jsonQueryDict['key'] if 'key' in jsonQueryDict else None
    debug(u"NBI Query:\n{}\n".format(jsonQuery))
    response = nbiSessionPost(jsonQuery, returnKeyError) if NbiUrl else emc_nbi.query(jsonQuery)
    debug("nbiQuery response = {}".format(response))
    if response == None: # Should only happen from nbiSessionPost if returnKeyError=True
        return None
    if 'errors' in response: # Query response contains errors
        if returnKeyError: # If we asked to return upon NBI error, then the error message will be held in LastNbiError
            LastNbiError = response['errors'][0].message
            return None
        abortError(u"nbiQuery for\n{}".format(jsonQuery), response['errors'][0].message)
    LastNbiError = None

    if returnKey: # If a specific key requested, we find it
        foundKey, returnValue = recursionKeySearch(response, returnKey)
        if foundKey:
            if Debug:
                if debugKey: debug("{} = {}".format(debugKey, returnValue))
                else: debug("nbiQuery {} = {}".format(returnKey, returnValue))
            return returnValue
        if returnKeyError:
            return None
        # If requested key not found, raise error
        abortError(u"nbiQuery for\n{}".format(jsonQuery), 'Key "{}" was not found in query response'.format(returnKey))

    # Else, return the full response
    if Debug:
        if debugKey: debug("{} = {}".format(debugKey, response))
        else: debug("nbiQuery response = {}".format(response))
    return response

def nbiMutation(jsonQueryDict, returnKeyError=False, debugKey=None, **kwargs): # v9 - Makes a GraphQl mutation query of XMC NBI; returns true on success
    global LastNbiError
    jsonQuery = replaceKwargs(jsonQueryDict['json'], kwargs) # Might be unicode
    returnKey = jsonQueryDict['key'] if 'key' in jsonQueryDict else None
    if Sanity:
        printLog(u"SANITY - NBI Mutation:\n{}\n".format(jsonQuery))
        LastNbiError = None
        return True
    printLog(u"NBI Mutation Query:\n{}\n".format(jsonQuery))
    response = nbiSessionPost(jsonQuery, returnKeyError) if NbiUrl else emc_nbi.query(jsonQuery)
    debug("nbiQuery response = {}".format(response))
    if 'errors' in response: # Query response contains errors
        if returnKeyError: # If we asked to return upon NBI error, then the error message will be held in LastNbiError
            LastNbiError = response['errors'][0].message
            return None
        abortError(u"nbiQuery for\n{}".format(jsonQuery), response['errors'][0].message)

    foundKey, returnStatus, returnMessage = recursionStatusSearch(response)
    if foundKey:
        debug("nbiMutation status = {} / message = {}".format(returnStatus, returnMessage))
    elif not returnKeyError:
        # If status key not found, raise error
        abortError(u"nbiMutation for\n{}".format(jsonQuery), 'Key "status" was not found in query response')

    if returnStatus == "SUCCESS":
        LastNbiError = None
        if returnKey: # If a specific key requested, we find it
            foundKey, returnValue = recursionKeySearch(response, returnKey)
            if foundKey:
                if Debug:
                    if debugKey: debug("{} = {}".format(debugKey, returnValue))
                    else: debug("nbiQuery {} = {}".format(returnKey, returnValue))
                return returnValue
            if returnKeyError:
                return None
            # If requested key not found, raise error
            abortError(u"nbiMutation for\n{}".format(jsonQuery), 'Key "{}" was not found in mutation response'.format(returnKey))
        return True
    else:
        LastNbiError = returnMessage
        return False


#
# IP address processing functions
# ip.py v5
#
import re                           # Used by maskToNumber

def ipToNumber(dottedDecimalStr): # v1 - Method to convert an IP/Mask dotted decimal address into a long number; can also use for checking validity of IP addresses
    try: # bytearray ensures that IP bytes are valid (1-255)
        ipByte = list(bytearray([int(byte) for byte in dottedDecimalStr.split('.')]))
    except:
        return None
    if len(ipByte) != 4:
        return None
    debug("ipByte = {}".format(ipByte))
    ipNumber = (ipByte[0]&lt;&lt;24) + (ipByte[1]&lt;&lt;16) + (ipByte[2]&lt;&lt;8) + ipByte[3]
    debug("dottedDecimalStr {} = ipNumber {}".format(dottedDecimalStr, hex(ipNumber)))
    return ipNumber

def numberToIp(ipNumber): # v1 - Method to convert a long number into an IP/Mask dotted decimal address
    dottedDecimalStr = '.'.join( [ str(ipNumber &gt;&gt; (i&lt;&lt;3) &amp; 0xFF) for i in range(4)[::-1] ] )
    debug("ipNumber {} = dottedDecimalStr {}".format(hex(ipNumber), dottedDecimalStr))
    return dottedDecimalStr

def maskToNumber(mask): # v1 - Method to convert a mask (dotted decimal or Cidr number) into a long number
    if isinstance(mask, int) or re.match(r'^\d+$', mask): # Mask as number
        if int(mask) &gt; 0 and int(mask) &lt;= 32:
            maskNumber = (2**32-1) ^ (2**(32-int(mask))-1)
        else:
            maskNumber = None
    else:
        maskNumber = ipToNumber(mask)
    if maskNumber:
        debug("maskNumber = {}".format(hex(maskNumber)))
    return maskNumber

def subnetMask(ip, mask): # v1 - Return the IP subnet and Mask in dotted decimal and cidr formats for the provided IP address and mask
    ipNumber = ipToNumber(ip)
    maskNumber = maskToNumber(mask)
    subnetNumber = ipNumber &amp; maskNumber
    ipSubnet = numberToIp(subnetNumber)
    ipDottedMask = numberToIp(maskNumber)
    ipCidrMask = bin(maskNumber).count('1')
    debug("ipSubnet = {} / ipDottedMask = {} / ipCidrMask = {}".format(ipSubnet, ipDottedMask, ipCidrMask))
    return ipSubnet, ipDottedMask, ipCidrMask

def ipGateway(ip, mask, gw): # v1 - Return the gateway IP address, as first or last IP in subnet, based on own IP/mask
    ipNumber = ipToNumber(ip)
    maskNumber = maskToNumber(mask)
    subnetNumber = ipNumber &amp; maskNumber
    if gw == 'first':
        gwNumber = subnetNumber + 1
        ip1numb = gwNumber + 1
        ip2numb = gwNumber + 2
    elif gw == 'last':
        gwNumber = subnetNumber + 2**(32-int(mask)) - 2
        ip1numb = gwNumber - 2
        ip2numb = gwNumber - 1
    else: # Error condition
        exitError('ipGateway(): invalid gw type {}'.format(gw))
    debug("gwNumber = {} / ip1numb = {} / ip2numb = {}".format(hex(gwNumber), hex(ip1numb), hex(ip2numb)))
    gatewayIP = numberToIp(gwNumber)
    ip1 = numberToIp(ip1numb)
    ip2 = numberToIp(ip2numb)
    debug("gatewayIP = {} / ip1 = {} / ip2 = {}".format(gatewayIP, ip1, ip2))
    return gatewayIP, ip1, ip2


#
# Save Config functions (requires cli.py v26)
# cliVossSave.py v6
#
import re                           # Used by vossSaveConfigRetry
import time                         # Used by vossSaveConfigRetry &amp; vossWaitNoUsersConnected

def vossSaveConfigRetry(waitTime=10, retries=3, returnCliError=False, aggressive=False): # v5 - On VOSS a save config can fail, if another CLI session is doing "show run", so we need to be able to backoff and retry
    # Only supported for family = 'VSP Series'
    global LastError
    cmd = 'save config'
    if Sanity:
        printLog("SANITY&gt; {}".format(cmd))
        ConfigHistory.append(cmd)
        LastError = None
        return True

    retryCount = 0
    while retryCount &lt;= retries:
        resultObj = emc_cli.send(cmd, True)
        if resultObj.isSuccess():
            outputStr = cleanOutput(resultObj.getOutput())
            if outputStr and re.search(r'Save config to file \S+ successful', outputStr): # Check for message indicating successful save
                ConfigHistory.append(cmd)
                LastError = None
                return True
            # If we get here, then the save did not happen, possibly because: "Another show or save in progress.  Please try the command later."
            retryCount += 1
            if retries &gt; 0:
                if aggressive and retryCount == retries:
                    # We become aggressive, we kill all other SSH/Telnet sessions
                    printLog("==&gt; Save config did not happen. Getting aggressive... killing all other CLI sessions...")
                    cliSessionsList = sendCLI_showRegex('list://show users||^(Telnet|SSH)(\d+) +\S+ +\S+ +[\d\.\:]+ *$', 'cliSessionsList')
                    for sessionTuple in cliSessionsList:
                        sendCLI_configCommand('clear {} {}'.format(sessionTuple[0], sessionTuple[1]), returnCliError=True, historyAppend=False)
                else: # Wait and try again
                    if retryCount &gt; retries:
                        printLog("==&gt; Save config did not happen. Exausted retries...")
                    else:
                        printLog("==&gt; Save config did not happen. Waiting {} seconds before retry...".format(waitTime))
                        time.sleep(waitTime)
                        printLog("==&gt; Retry {}\n".format(retryCount))
        else:
            exitError(resultObj.getError())

    if returnCliError: # If we asked to return upon CLI error, then the error message will be held in LastError
        LastError = outputStr
        return False
    exitError(outputStr)

def vossWaitNoUsersConnected(waitTime=10, retries=3, aggressive=False): # v4 - Waits until no other Telnet/SSH connections to VSP switch
    # Only supported for family = 'VSP Series'
    retryCount = 0
    while retryCount &lt;= retries:
        if sendCLI_showRegex('bool://show users||^(?:Telnet|SSH).+\d *$'):
            retryCount += 1
            if retries &gt; 0:
                if aggressive and retryCount == retries:
                    # We become aggressive, we kill all other SSH/Telnet sessions
                    printLog("==&gt; Some users are still connected. Getting aggressive... killing all other CLI sessions...")
                    cliSessionsList = sendCLI_showRegex('list://show users||^(Telnet|SSH)(\d+) +\S+ +\S+ +[\d\.\:]+ *$', 'cliSessionsList')
                    for sessionTuple in cliSessionsList:
                        sendCLI_configCommand('clear {} {}'.format(sessionTuple[0], sessionTuple[1]), returnCliError=True, historyAppend=False)
                else: # Wait and try again
                    if retryCount &gt; retries:
                        printLog("==&gt; Some users are still connected. Exausted retries...")
                        return False
                    else:
                        printLog("==&gt; Some users are still connected. Waiting {} seconds before retry...".format(waitTime))
                        time.sleep(waitTime)
                        printLog("==&gt; Retry {}\n".format(retryCount))
        else:
            return True


#
# Syslog functions
# syslog.py v1
#
import socket

def addXmcSyslogEvent(severity, message, ip=None): # v1 - Adds a syslog event to XMC (only needed for Scripts)
    severityHash = {'emerg': 0, 'alert': 1, 'crit': 2, 'err': 3, 'warning': 4, 'notice': 5, 'info': 6, 'debug': 7}
    severityLevel = severityHash[severity] if severity in severityHash else 6
    session = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, 0)
    session.connect(('127.0.0.1', 514))
    if ip:
        session.send("&lt;{}&gt; XMC Script {} / Device: {} / {}".format(severityLevel,scriptName(),ip,message))
    else:
        session.send("&lt;{}&gt; XMC Script {} / {}".format(severityLevel,scriptName(),ip,message))
    session.close()


#
# Other Custom Functions
# misc.py
def extractSpbmGlobal(): # v1 - Tricky command to extract from, as it is different across VOSS, VSP8600 and XA
    # Only supported for family = 'VSP Series'
    cmd = 'list://show isis spbm||(?:(B-VID) +PRIMARY +(NICK) +LSDB +(IP)(?: +(IPV6))?(?: +(MULTICAST))?|^\d+ +(?:(\d+)-(\d+) +\d+ +)?(?:([\da-f]\.[\da-f]{2}\.[\da-f]{2}) +)?(?:disable|enable) +(disable|enable)(?: +(disable|enable))?(?: +(disable|enable))?|^\d+ +(?:primary|secondary) +([\da-f:]+)(?: +([\da-f\.]+))?)'
    data = sendCLI_showRegex(cmd)
    # VOSS:[(u'B-VID', u'NICK', u'IP', u'IPV6', u'MULTICAST', u'', u'', u'', u'', u'', u'', u'', u''), (u'', u'', u'', u'', u'', u'4051', u'4052', u'0.00.75', u'enable', u'disable', u'disable', u'', u''),           (u'', u'', u'', u'', u'', u'', u'', u'', u'', u'', u'', u'00:00:00:00:00:00', u'')]
    # V86: [(u'B-VID', u'NICK', u'IP', u'', u'MULTICAST', u'', u'', u'', u'', u'', u'', u'', u''),     (u'', u'', u'', u'', u'', u'4051', u'4052', u'0.00.11', u'enable',             u'disable', u'', u'', u''),      (u'', u'', u'', u'', u'', u'', u'', u'', u'', u'', u'', u'82:bb:00:00:11:ff', u'82bb.0000.1200')]
    # XA:  [(u'B-VID', u'NICK', u'IP', u'', u'', u'', u'', u'', u'', u'', u'', u'', u''),              (u'', u'', u'', u'', u'', u'4051', u'4052', u'0.00.46', u'enable',                         u'', u'', u'', u'')]
    dataDict = {
        'SpbmInstance' : False,
        'BVIDs'        : [],
        'Nickname'     : None,
        'IP'           : None,
        'IPV6'         : None,
        'Multicast'    : None,
        'SmltVirtBmac' : None,
        'SmltPeerBmac' : None,
    }
    if len(data) &gt; 1: # If we did not just match the banner line
        dataDict['SpbmInstance'] = True
        if data[1][5] and data[1][6]:
            dataDict['BVIDs'] = [data[1][5],data[1][6]]
        else:
            dataDict['BVIDs'] = []
        dataDict['Nickname'] = data[1][7]
        dataDict['IP'] = data[1][8]
        if data[0][3] == 'IPV6':
            dataDict['IPV6'] = data[1][9]
            if data[0][4] == 'MULTICAST':
                dataDict['Multicast'] = data[1][10]
        else:
            if data[0][4] == 'MULTICAST':
                dataDict['Multicast'] = data[1][9]
    if len(data) == 3: # We got SMLT data (on XA we don't have the line)
        if data[2][11] and data[2][11] != '00:00:00:00:00:00':
            dataDict['SmltVirtBmac'] = data[2][11]
            dataDict['SmltPeerBmac'] = data[2][12]
    debug("extractSpbmGlobal() = {}".format(dataDict))
    return dataDict


#
# INIT: Init Debug &amp; Sanity flags based on input combos
#
try:
    if emc_vars['userInput_sanity'].lower() == 'enable':
        Sanity = True
    elif emc_vars['userInput_sanity'].lower() == 'disable':
        Sanity = False
except:
    pass
try:
    if emc_vars['userInput_debug'].lower() == 'enable':
        Debug = True
    elif emc_vars['userInput_debug'].lower() == 'disable':
        Debug = False
except:
    pass


#
# MAIN:
#
def main():
    print "{} version {} on XIQ-SE version {}".format(scriptName(), __version__, emc_vars["serverVersion"])
    nbiAccess = nbiQuery(NBI_Query['nbiAccess'], returnKeyError=True)
    if nbiAccess == None:
        exitError('This XIQ-SE Script requires access to the GraphQl North Bound Interface (NBI). Make sure that XIQ-SE is running with an Advanced license and that your user profile is authorized for Northbound API.')

    #
    # Obtain Info on switch and from XIQ-SE
    #
    currentIp           = emc_vars["deviceIP"]
    newVrf              = emc_vars["userInput_vrf"].strip()
    mgmtVlanIpAction    = emc_vars["userInput_mgmtVlanIp"].lower()
    newIp               = emc_vars["userInput_ip"].strip()
    newSysName          = emc_vars["userInput_sysname"].strip()

    print "Information provided by User:"
    print " - New CLIP VRF = {}".format(newVrf)
    print " - Existing Mgmt VLAN IP action = {}".format(mgmtVlanIpAction)
    print " - New CLIP IP = {}".format(newIp)
    print " - New System Name = {}".format(newSysName)

    vossVersion = emc_vars["deviceSoftwareVer"]

    print "Switch information:"
    print " - VOSS software version = {}".format(vossVersion)
    print
    print "Other settings:"
    print " - Delay time before re-adding device to XIQ-SE = {} secs".format(delaySiteReAdd)
    print " - Delay time before trying to re-connect to device after re-adding it to XIQ-SE = {} secs".format(delayReConnect)
    print " - CLI retries = {}".format(cliRetries)
    print " - CLI retry delay = {}".format(cliRetryDelay)
    print

    # VOSS version validation
    if re.match(r'(?:[1-7]\.|8\.[01]\.)', vossVersion):
        exitError('This script only works on VSPs running VOSS 8.2 or later')

    # IP validation
    if not ipToNumber(newIp):
        exitError('Invalid VLAN IP address {}'.format(newIp))
    if newIp == currentIp:
        exitError('Given IP {} is already used to manange the switch'.format(newIp))

    # Sys-name validation
    if re.search(r'\s', newSysName):
        exitError('System Name provided must not contain any spaces: "{}"'.format(newSysName))

    # VRF validation
    if not newVrf:
        newVrf = 'GlobalRouter'

    # Check if given IP is already in XIQ-SE
    checkNewIpInXmc = nbiQuery(NBI_Query['checkSwitchXmcDb'], IP=newIp)
    if checkNewIpInXmc:
        exitError("Given IP address {} is already in XIQ-SE's database".format(newIp))

    # Check if given IP is already out there
    response = os.system("ping -c 1 " + newIp)
    if response == 0: # Response from ping
        exitError("Given IP address {} is already on the network (replies to ping)".format(newIp))

    # Get the site path for device
    sitePath = nbiQuery(NBI_Query['getSitePath'], IP=currentIp)

    # Find the Admin Profile which was in use for this device
    adminProfile = nbiQuery(NBI_Query['getDeviceAdminProfile'], IP=currentIp)

    # Disable more paging
    sendCLI_showCommand(CLI_Dict[Family]['disable_more_paging'], retries=cliRetries, retryDelay=cliRetryDelay)

    # Enter privExec
    sendCLI_showCommand(CLI_Dict[Family]['enable_context'])

    # Get the mask of the IP we are using now
    currentIpMask = sendCLI_showRegex(CLI_Dict[Family]['get_mgmt_ip_mask'].format(currentIp))
    if not currentIpMask:
        exitError("Cannot determine mask of existing IP {}".format(currentIp))

    # Compare subnets for same mask (when moving from mgmt vlan IP to clip IP, ensure the clip IP is not in vlan IP subnet)
    if subnetMask(currentIp, currentIpMask)[0] == subnetMask(newIp, currentIpMask)[0]:
        exitError("New IP {} seems to be in same subnet of existing IP {}".format(newIp, currentIp))

    # Check if node is a DVR Leaf
    dvrNodeType = sendCLI_showRegex(CLI_Dict[Family]['get_dvr_type'], 'dvrNodeType', True, "No DVR support on this switch")

    if dvrNodeType == 'leaf': # Processing diverges based on DVR Leaf or regular BEB
        # Verify the VRF is GRT
        if newVrf != 'GlobalRouter':
            exitError("Switch is a DVR Leaf and mgmt clip can only be applied on GlobalRouter VRF")

    else: # Regular BEB
        # Verify VRF existence
        if newVrf != 'GlobalRouter':
            vrfExists = sendCLI_showRegex(CLI_Dict[Family]['check_vrf_exists'].format(newVrf))
            if not vrfExists:
                exitError("VRF {} does not exist on switch; cannot create a mgmt clip for non-existent VRF".format(newVrf))

        # For a VRF other than GRT, we also need to check that ipvpn is enabled
        if newVrf != 'GlobalRouter':
            vrfL3vsnExists = sendCLI_showRegex(CLI_Dict[Family]['check_vrf_l3vsn'].format(newVrf))
            if not vrfL3vsnExists:
                exitError("VRF {} must be a L3VSN (ipvpn enabled) before assigning a mgmt clip to it".format(newVrf))

        # Verify if IP Shortcuts is enabled (GRT alone, if it wasn't and a VRF was specified, we would have errored above)
        spbmGlobalDict = extractSpbmGlobal()
        if not spbmGlobalDict['IP'] == 'enable':
            print "IP Shortcuts (spbm ip enable) is not enabled and will be enabled by this script (but no ISIS ip-source-address will be set)"

    # Verify whether mgmt clip is already set
    mgmtIfList = sendCLI_showRegex(CLI_Dict[Family]['list_mgmt_interfaces'])
    mgmtIpDict = sendCLI_showRegex(CLI_Dict[Family]['list_mgmt_ips'])

    # Enter Config context
    sendCLI_configCommand(CLI_Dict[Family]['config_context'])

    if 'CLIP' in mgmtIfList: # Here a mgmt clip already exists, and we are trying to change it
        # Queue delete of existing mgmt clip
        warpBuffer_add(CLI_Dict[Family]['delete_mgmt_clip'])

        # Queue creation of new mgmt clip
        warpBuffer_add(CLI_Dict[Family]['create_mgmt_clip'].format(newVrf, newIp))

    else: # Here no mgmt clip exists, so we can take a safer approach...
        # For GRT + regular BEB + IP Shortcuts not enabled, we enable IP Shortcuts
        if (not dvrNodeType == 'leaf' and not spbmGlobalDict['IP'] == 'enable'):
            sendCLI_configChain(CLI_Dict[Family]['enable_ip_shortcuts'])
            rollbackCommand(CLI_Dict[Family]['disable_ip_shortcuts'])

        # Go ahead and create the new mgmt clip
        sendCLI_configChain(CLI_Dict[Family]['create_mgmt_clip'].format(newVrf, newIp))
        rollbackCommand(CLI_Dict[Family]['delete_mgmt_clip'])

        # Now check if the IP is reachable by XIQ-SE
        print "Waiting up to 10secs for new CLIP Mgmt IP to reply to ping"
        if not Sanity:
            retries = 0
            response = None
            while not retries &gt; 10:
                response = os.system("ping -c 1 " + newIp)
                if response == 0: # Response from ping
                    break
                retries += 1
                print " - {} timeout".format(retries)
            if response == 1: # No response from ping
                abortError("ping {}".format(newIp), "Newly configured clip IP {} not reachable by XIQ-SE; rolling back changes".format(newIp))
            print " - reply from {}".format(newIp)

    # Queue change of sys-name
    if newSysName:
        warpBuffer_add(CLI_Dict[Family]['change_sys_name'].format(newSysName))

    # Execute queued buffer
    warpBuffer_execute(waitForPrompt=False)
    addXmcSyslogEvent('info', "Changed IP address to {}".format(newIp), currentIp)

    # Close the connection
    if not Sanity:
        emc_cli.close()

    # Delete the old IP from XIQ-SE
    if not nbiMutation(NBI_Query['delete_device'], IP=currentIp):
        exitError("Failed to delete IP '{}' from XIQ-SE's database".format(currentIp))
    addXmcSyslogEvent('info', "Deleted device from XIQ-SE database", currentIp)
    print "Deleted device {} from XIQ-SE database".format(currentIp)

    # Record time, as we'll need not to re-add the switch too quickly, because...
    # ... sometimes, XIQ-SE is a bit slow to complete the deletion, and we don't want the re-add below to fail because of "Device already exists"
    # ... seen occasions where if we re-add too quick XIQ-SE then tanks in acquiring XIQ license for re-added device
    deleteTime = time.time()

    # Check whether switch was added to AccessControl
    switchNacExists = nbiQuery(NBI_Query['checkSwitchNacConfig'], IP=currentIp)
    # Sample of what we should get back
    # "switch": {
    #         "ipAddress": "10.8.4.2"
    # }
    # Or we get None
    if switchNacExists:
        if not nbiMutation(NBI_Query['accessControlDeleteSwitch'], IP=currentIp): # Delete the switch from AccessControl
            exitError("Failed to delete existing switch IP '{}' in NAC Engine Group".format(ipAddress))
        addXmcSyslogEvent('info', "Deleted device from XIQ-SE Control", currentIp)
        print "Deleted device {} from XIQ-SE NAC engine".format(currentIp)

        # Check whether switch was added to any NAC Location Groups
        # For this we need to get a list of all Location Groups
        nacLocationGroups = nbiQuery(NBI_Query['getNacLocationGroups'])
        # Sample of what we should get back
        # "groupNamesByType": [
        #   "Branch3",
        #   "Branch2",
        #   "Branch1",
        # ]
        # Or we get []

        # And then we methodically delete the switch from all those groups
        for group in nacLocationGroups:
            # Delete the switch from Location Group
            if nbiMutation(NBI_Query['accessControlRemoveSwitchFromLocation'], LOCATIONGROUP=group, IP=currentIp):
                addXmcSyslogEvent('info', "Deleted device from XIQ-SE Control Location Group: {}".format(group), currentIp)
                print "Deleted device {} from Location Group: {}".format(currentIp, group)
            # We don't check for errors, as we don't expect to find the IP in all location groups

    # Sleep enough to meet delaySiteReAdd from delete time
    sleepTime = delaySiteReAdd - ( time.time() - deleteTime ) 
    if sleepTime &gt; 0:
        print "\nSleeping {} seconds, to ensure that device can be successfully re-added to XIQ-SE\n".format(sleepTime)
        if not Sanity:
            time.sleep(sleepTime)

    # Create the new IP device in XIQ-SE
    deviceReAdded = False
    addRetries = 0
    while not deviceReAdded and addRetries &lt; 2: # We can try twice, as sometimes XIQ-SE fails to add the device...
        if not nbiMutation(NBI_Query['create_device'], IP=newIp, SITE=sitePath, PROFILE=adminProfile):
            exitError("Failed to add new device IP '{}' to XIQ-SE Site '{}' with admin profile '{}'".format(newIp, sitePath, adminProfile))
        addXmcSyslogEvent('info', "Added device to XIQ-SE Site {}".format(sitePath), newIp)
        print "Re-added device to XIQ-SE using new CLIP IP {} and admin profile '{}'".format(newIp, adminProfile)
        addRetries += 1

        # Wait enough time for XIQ-SE to process the newly re-added switch
        print "Waiting for device to be re-added to XIQ-SE's database"
        if Sanity:
            deviceReAdded = True
        else:
            retries = 0
            while not retries &gt; 20:
                time.sleep(5)
                if nbiQuery(NBI_Query['check_device'], IP=newIp):
                    # Sample of what we should get back
                    # "device": {
                    #   "down": false
                    # }
                    # Or we get null
                    deviceReAdded = True
                    print "Device is re-added to XIQ-SE"
                    break
                retries += 1
                print " - retry {}".format(retries)
        print
        if not deviceReAdded:
            print "Add retries = {}".format(addRetries)

    # Try and re-open session against the new CLIP IP
    if not deviceReAdded:
        exitError("Failed to re-add device IP '{}' to XIQ-SE after {} retries; try manually.".format(newIp, addRetries))

    print "Waiting {} seconds before re-connecting".format(delayReConnect)
    if not Sanity:
        time.sleep(delayReConnect)

    print "Attempting to re-connect on new CLIP IP"

    if not Sanity:
        emc_cli.setIpAddress(newIp)

    # Disable more paging
    sendCLI_showCommand(CLI_Dict[Family]['disable_more_paging'], retries=cliRetries, retryDelay=cliRetryDelay)

    # Enter privExec
    sendCLI_showCommand(CLI_Dict[Family]['enable_context'])

    # If we wanted to delete the existing VLAN IP
    if 'VLAN' in mgmtIfList and 'vlan' in mgmtIpDict and mgmtVlanIpAction == 'delete':
        # Enter Config context
        sendCLI_configCommand(CLI_Dict[Family]['config_context'])
        # Delete of existing mgmt vlan
        if dvrNodeType == 'leaf':
            sendCLI_configChain(CLI_Dict[Family]['delete_mgmt_vlan_dvr_leaf'].format(mgmtIpDict['vlan']))
        else:
            sendCLI_configChain(CLI_Dict[Family]['delete_mgmt_vlan'])
        # Exit Config context
        sendCLI_configCommand(CLI_Dict[Family]['end_config'])

    # Save the config
    vossSaveConfigRetry(waitTime=10, retries=3)

    # Print summary of config performed
    printConfigSummary()
    print "Deleted IP '{}' from XIQ-SE's database".format(currentIp)
    if switchNacExists:
        print "Deleted IP '{}' in NAC Engine Group".format(currentIp)
    print "Added new device IP '{}' to XIQ-SE Site '{}' with admin profile '{}'".format(newIp, sitePath, adminProfile)

    # Exit code will be success if we get here
    emc_results.setStatus(emc_results.Status.SUCCESS)
    print "Exit code SUCCESS"

main()
</content>
    <creationDate>1653402348109</creationDate>
    <creator>root</creator>
    <credentialsCacheOveride>false</credentialsCacheOveride>
    <defaultCategory></defaultCategory>
    <devicesRequired>true</devicesRequired>
    <encoded>true</encoded>
    <contexts>,Device,Groups,</contexts>
    <lastUpdateDate>1756503484701</lastUpdateDate>
    <lastUpdatedBy>root</lastUpdatedBy>
    <miscXMLData></miscXMLData>
    <nosIds>,nos-id-voss,nos-id-fabric-engine,</nosIds>
    <postprocessScript></postprocessScript>
    <rollbackScript></rollbackScript>
    <saveConfigOnExit>false</saveConfigOnExit>
    <scriptOwner></scriptOwner>
    <scriptTimeout>60</scriptTimeout>
    <scriptType>Python</scriptType>
    <supprotedGroups></supprotedGroups>
    <roles>,XIQ-SE Administrator,</roles>
    <vendor></vendor>
    <version>0</version>
</script>

