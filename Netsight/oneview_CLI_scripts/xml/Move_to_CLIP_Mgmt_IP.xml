<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<script name="Move to CLIP Mgmt IP">
    <abortOnError>true</abortOnError>
    <auditLogEnabled></auditLogEnabled>
    <category>,Provisioning,</category>
    <comments>Create mgmt clip IP on VSP and re-add to XMC with that new IP - v1.1</comments>
    <content>'''
This script is provided free of charge by Extreme. We hope such scripts are
helpful when used in conjunction with Extreme products and technology and can
be used as examples to modify and adapt for your ultimate requirements.
Extreme will not provide any official support for these scripts. If you do
have any questions or queries about any of these scripts you may post on
Extreme's community website "The Hub" (https://community.extremenetworks.com/)
under the scripting category.

ANY SCRIPTS PROVIDED BY EXTREME ARE HEREBY PROVIDED "AS IS", WITHOUT WARRANTY
OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL EXTREME OR ITS THIRD PARTY LICENSORS BE LIABLE FOR ANY CLAIM,
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE USE OR DISTRIBUTION OF SUCH
SCRIPTS.
'''

# --&gt; Insert here script description, version and metadata &lt;--

##########################################################
# XMC Script: Move Switch to CLIP mgmt IP                #
# Written by Ludovico Stevens, TME Extreme Networks      #
##########################################################

__version__ = '1.1'

# 1.0	- Initial
# 1.1	- Some extra IP validation checks

'''
#@MetaDataStart
#@DetailDescriptionStart
#######################################################################################
# 
# Given a switch already in XMC, this script will ask user to provide a CLIP IP and VRF
# which will then be configured as mgmt clip on the VSP. If the VSP already had a mgmt
# clip the existing mgmt clip will be deleted and replaced with the new one. If the
# switch had a mgmt vlan IP, this will also be deleted.
# Finally the switch is deleted from XMC's database as well as XMC Control if there,
# and re-added to the same site with the new mgmt IP address.
# Before attempting to change the IP on the switch, the script will first of all make
# sure that the new IP address provided is not already known by XMC and that it does
# not exist on the network (does not reply to ping)
#
#######################################################################################
#@DetailDescriptionEnd
# ( = &amp;#40;
# ) = &amp;#41;
# , = &amp;#44;
# &lt; = &amp;lt;
# &gt; = &amp;gt;
#@SectionStart (description = "New switch mgmt circuitless IP")
#    @VariableFieldLabel (
#        description = "New IP &amp;#40;mask will be 32bits&amp;#41;",
#        type = string,
#        required = yes,
#        name = "userInput_ip",
#    )
#    @VariableFieldLabel (
#        description = "Associated VRF name &amp;#40;default is GRT&amp;#41;",
#        type = string,
#        required = no,
#        name = "userInput_vrf",
#        value = "GlobalRouter",
#    )
#@SectionEnd
#@SectionStart (description = "Sanity / Debug")
#    @VariableFieldLabel (
#        description = "Sanity: enable if you do not trust this script and wish to first see what it does. In sanity mode config commands are not executed",
#        type = string,
#        required = no,
#        validValues = [Enable, Disable],
#        name = "userInput_sanity",
#    )
#    @VariableFieldLabel (
#        description = "Debug: enable if you need to report a problem to the script author",
#        type = string,
#        required = no,
#        validValues = [Enable, Disable],
#        name = "userInput_debug",
#    )
#@SectionEnd
#@MetaDataEnd
'''



##########################################################
# Ludo Standard library; Version 3.00                    #
# Written by Ludovico Stevens, TME Extreme Networks      #
##########################################################
Debug = False    # Enables debug messages
Sanity = False   # If enabled, config commands are not sent to host (show commands are operational)

##########################################################
try:
    emc_vars
    execution = 'xmc'
except: # If not running on XMC Jython...
    # These lines only needed to run XMC Python script locally (on my laptop)
    # They can also be pasted to XMC, but will not execute
    import sys
    import json
    import java.util
    import emc_cli      # Own local replica
    import emc_nbi      # Own local replica
    import emc_results  # Own local replica
    execution = 'dev'
    if len(sys.argv) &gt; 1: # Json file as 1st argv
        emc_vars = json.load(open(sys.argv[1]))
    else:
        emc_vars = json.load(open('emc_vars.json'))
##########################################################

#
# IMPORTS:
#
import re
import os                           # Used by warpBuffer_execute
from java.util import LinkedHashMap # Used by nbiQuery
import socket                       # Used by addXmcSyslogEvent

#
# VARIABLES:
#

# For CLI functions:
RegexPrompt = re.compile('.*[\?\$%#&gt;]\s?$')
RegexError  = re.compile(
    '^%|\x07|error|invalid|cannot|unable|bad|not found|not exist|not allowed|no such|out of range|incomplete|failed|denied|can\'t|ambiguous|do not|unrecognized',
    re.IGNORECASE
)
RegexContextPatterns = { # Ported from acli.pl
    'ERS Series' : [
        re.compile('^(?:interface |router \w+$|route-map (?:\"[\w\d\s\.\+-]+\"|[\w\d\.-]+) \d+$|ip igmp profile \d+$|wireless|application|ipv6 dhcp guard policy |ipv6 nd raguard policy )'), # level0
        re.compile('^(?:security|crypto|ap-profile |captive-portal |network-profile |radio-profile )'), # level1
        re.compile('^(?:locale)'), # level2
    ],
    'VSP Series' : [
        re.compile('^ *(?:interface |router \w+$|router vrf|route-map (?:\"[\w\d\s\.\+-]+\"|[\w\d\.-]+) \d+$|application|i-sid \d+|wireless|logical-intf isis \d+|mgmt [\dcvo]|ovsdb$)'), # level0
        re.compile('^ *(?:route-map (?:\"[\w\d\s\.\+-]+\"|[\w\d\.-]+) \d+$)'), # level1
    ],
}
RegexExitInstance = re.compile('^ *(?:exit|back|end)(?:\s|$)')
Indent = 3 # Number of space characters for each indentation
LastError = None
ConfigHistory = []
WarpBuffer = []

# For CLI Rollback functions
RollbackStack = []

# For Port functions
RegexPort = re.compile('^(?:[1-9]\d{0,2}[/:])?\d+$')
RegexPortRange = re.compile('^(?:([1-9]\d{0,2})([/:]))?(\d+)-(?:([1-9]\d{0,2})[/:])?(\d+)$')
RegexStarRange = re.compile('^([1-9]\d{0,2})(:)\*$') # XOS only
SlotPortRange = None # Gets set to dict by getSlotPortRanges()

# For Family functions
Family = None # This needs to get set by setFamily()
FamilyChildren = { # Children will be rolled into parent family for these scripts
    'Extreme Access Series' : 'VSP Series',
    'Unified Switching VOSS': 'VSP Series',
    'Unified Switching EXOS': 'Summit Series',
}

#
# FUNCTIONS:
#
def debug(debugOutput): # Use function to include debugging in script; set above Debug variable to True or False to turn on or off debugging
    if Debug:
        print debugOutput

def exitError(errorOutput): # Exit script with error message and setting status appropriately
    emc_results.setStatus(emc_results.Status.ERROR)
    raise RuntimeError(errorOutput)

def abortError(cmd, errorOutput): # A CLI command failed, before bombing out send any rollback commands which may have been set
    print "Aborting script due to error on previous command"
    try:
        rollbackStack()
    finally:
        print "Aborting because this command failed: {}".format(cmd)
        exitError(errorOutput)

def scriptName(): # Returns the assigned name of the Script or Workflow
    name = None
    if 'workflowName' in emc_vars: # Workflow
        name = emc_vars['workflowName']
    elif 'javax.script.filename' in emc_vars: # Script
        nameMatch = re.search(r'\/([^\/\.]+)\.py$', emc_vars['javax.script.filename'])
        name = nameMatch.group(1) if nameMatch else None
    return name

#
# Family functions
#

def setFamily(): # Set global Family variable; automatically handles family children, as far as this script is concerned
    global Family
    if emc_vars["family"] in FamilyChildren:
        Family = FamilyChildren[emc_vars["family"]]
    else:
        Family = emc_vars["family"]
    print "Using family type '{}' for this script".format(Family)
    if Family not in CLI_Dict:
        exitError('This scripts only supports family types: {}'.format(", ".join(list(CLI_Dict.keys()))))


#
# CLI functions
#

def cleanOutput(outputStr): # Remove echoed command and final prompt from output
    lastLine = outputStr.splitlines()[-1:][0]
    if RegexPrompt.match(lastLine):
        lines = outputStr.splitlines()[1:-1]
    else:
        lines = outputStr.splitlines()[1:]
    return '\n'.join(lines)

def configChain(chainStr): # Produces a list of a set of concatenated commands (either with ';' or newlines)
    chainStr = re.sub(r'\n(\w)(\n|\s*;|$)', chr(0) + r'\1\2', chainStr) # Mask trailing "\ny" or "\nn" on commands before making list
    cmdList = map(str.strip, re.split(r'[;\n]', chainStr))
    cmdList = filter(None, cmdList) # Filter out empty lines, if any
    cmdList = [re.sub(r'\x00(\w)(\n|$)', r'\n\1\2', x) for x in cmdList] # Unmask after list made
    return cmdList

def parseRegexInput(cmdRegexStr): # Parses input command regex for both sendCLI_showRegex() and xmcLinuxCommand()
    # cmdRegexStr format: &lt;type&gt;://&lt;cli-show-command&gt; [&amp; &lt;additional-show-cmd&gt;]||&lt;regex-to-capture-with&gt;
    if re.match(r'\w+(?:-\w+)?://', cmdRegexStr):
        mode, cmdRegexStr = map(str.strip, cmdRegexStr.split('://', 1))
    else:
        mode = None
    cmd, regex = map(str.strip, cmdRegexStr.split('||', 1))
    cmdList = map(str.strip, cmd.split('&amp;'))
    return mode, cmdList, regex

def formatOutputData(data, mode): # Formats output data for both sendCLI_showRegex() and xmcLinuxCommand()
    if not mode                 : value = data                                   # Legacy behaviour same as list
    elif mode == 'bool'         : value = bool(data)                             # No regex capturing brackets required
    elif mode == 'str'          : value = str(data[0]) if data else None         # Regex should have 1 capturing bracket at most
    elif mode == 'str-lower'    : value = str(data[0]).lower() if data else None # Same as str but string made all lowercase
    elif mode == 'str-upper'    : value = str(data[0]).upper() if data else None # Same as str but string made all uppercase
    elif mode == 'int'          : value = int(data[0]) if data else None         # Regex must have 1 capturing bracket at most
    elif mode == 'list'         : value = data                                   # If &gt; 1 capturing brackets, will be list of tuples
    elif mode == 'list-reverse' : value = list(reversed(data))                   # Same as list but in reverse order
    elif mode == 'list-diagonal': value = [data[x][x] for x in range(len(data))] # Regex pat1|pat2 = list of tuples; want [0][0],[1][1],etc
    elif mode == 'tuple'        : value = data[0] if data else ()                # Regex &gt; 1 capturing brackets, returns 1st tuple
    elif mode == 'dict'         : value = dict(data)                             # Regex must have 2 capturing brackets exactly
    elif mode == 'dict-reverse' : value = dict(map(reversed, data))              # Same as dict, but key/values will be flipped
    elif mode == 'dict-both'    : value = dict(data), dict(map(reversed, data))  # Returns 2 dict: dict + dict-reverse
    elif mode == 'dict-diagonal': value = dict((data[x][x*2],data[x][x*2+1]) for x in range(len(data))) # {[0][0]:[0][1], [1][2]:[1][3], etc}
    else:
        RuntimeError("sendCLI_showRegex: invalid scheme type '{}'".format(mode))
    return value

def sendCLI_showCommand(cmd, returnCliError=False, msgOnError=None): # Send a CLI show command; return output
    global LastError
    resultObj = emc_cli.send(cmd)
    if resultObj.isSuccess():
        outputStr = cleanOutput(resultObj.getOutput())
        if outputStr and RegexError.search("\n".join(outputStr.split("\n")[:4])): # If there is output, check for error in 1st 4 lines only (timestamp banner might shift it by 3 lines)
            if returnCliError: # If we asked to return upon CLI error, then the error message will be held in LastError
                LastError = outputStr
                if msgOnError:
                    print "==&gt; Ignoring above error: {}\n\n".format(msgOnError)
                return None
            abortError(cmd, outputStr)
        LastError = None
        return outputStr
    else:
        exitError(resultObj.getError())

def sendCLI_showRegex(cmdRegexStr, debugKey=None, returnCliError=False, msgOnError=None): # Send show command and extract values from output using regex
    # Regex is by default case-sensitive; for case-insensitive include (?i) at beginning of regex on input string
    mode, cmdList, regex = parseRegexInput(cmdRegexStr)
    for cmd in cmdList:
        # If cmdList we try each command in turn until one works; we don't want to bomb out on cmds before the last one in the list
        ignoreCliError = True if len(cmdList) &gt; 1 and cmd != cmdList[-1] else returnCliError
        outputStr = sendCLI_showCommand(cmd, ignoreCliError, msgOnError)
        if outputStr:
            break
    if not outputStr: # returnCliError true
        return None
    data = re.findall(regex, outputStr, re.MULTILINE)
    debug("sendCLI_showRegex() raw data = {}".format(data))
    # Format we return data in depends on what '&lt;type&gt;://' was pre-pended to the cmd &amp; regex
    value = formatOutputData(data, mode)
    if Debug:
        if debugKey: debug("{} = {}".format(debugKey, value))
        else: debug("sendCLI_showRegex OUT = {}".format(value))
    return value

def sendCLI_configCommand(cmd, returnCliError=False, msgOnError=None, waitForPrompt=True): # Send a CLI config command
    global LastError
    cmdStore = re.sub(r'\n.+$', '', cmd) # Strip added CR+y or similar
    if Sanity:
        print "SANITY&gt; {}".format(cmd)
        ConfigHistory.append(cmdStore)
        LastError = None
        return True
    resultObj = emc_cli.send(cmd, waitForPrompt)
    if resultObj.isSuccess():
        outputStr = cleanOutput(resultObj.getOutput())
        if outputStr and RegexError.search("\n".join(outputStr.split("\n")[:2])): # If there is output, check for error in 1st 2 lines only
            if returnCliError: # If we asked to return upon CLI error, then the error message will be held in LastError
                LastError = outputStr
                if msgOnError:
                    print "==&gt; Ignoring above error: {}\n\n".format(msgOnError)
                return False
            abortError(cmd, outputStr)
        ConfigHistory.append(cmdStore)
        LastError = None
        return True
    else:
        exitError(resultObj.getError())

def sendCLI_configChain(chainStr, returnCliError=False, msgOnError=None, waitForPrompt=True): # Send a semi-colon separated list of config commands
    cmdList = configChain(chainStr)
    for cmd in cmdList[:-1]: # All but last
        success = sendCLI_configCommand(cmd, returnCliError, msgOnError)
        if not success:
            return False
    # Last now
    success = sendCLI_configCommand(cmdList[-1], returnCliError, msgOnError, waitForPrompt)
    if not success:
        return False
    return True

def warpBuffer_add(chainStr): # Preload WarpBuffer with config or configChains; buffer can then be executed with warpBuffer_execute()
    global WarpBuffer
    cmdList = configChain(chainStr)
    for cmd in cmdList:
        cmdAdd = re.sub(r'\n.+$', '', cmd) # Strip added CR+y or similar (these are not required when sourcing from file on VOSS and do not work on ERS anyway)
        WarpBuffer.append(cmdAdd)

def warpBuffer_execute(chainStr=None, returnCliError=False, msgOnError=None, waitForPrompt=True): # Appends to existing WarpBuffer and then executes it
    # Same as sendCLI_configChain() but all commands are placed in a script file on the switch and then sourced there
    # Apart from being fast, this approach can be used to make config changes which would otherwise result in the switch becomming unreachable
    # Use of this function assumes that the connected device (VSP) is already in privExec + config mode
    global WarpBuffer
    xmcTftpRoot = '/tftpboot'
    xmcServerIP = emc_vars["serverIP"]
    switchIP = emc_vars["deviceIP"]
    userName = emc_vars["userName"]
    tftpCheck = {
        'VSP Series':    'bool://show boot config flags||^flags tftpd true',
        'Summit Series': 'bool://show process tftpd||Ready',
        'ERS Series':    True, # Always enabled
    }
    tftpActivate = {
        'VSP Series':    'boot config flags tftpd',
        'Summit Series': 'start process tftpd',
    }
    tftpDeactivate = {
        'VSP Series':    'no boot config flags tftpd',
        'Summit Series': 'terminate process tftpd graceful',
    }
    tftpExecute = { # XMC server IP (TFTP server), Script file to fetch and execute
        'VSP Series':    'copy {0}:{1} /intflash/.script.src -y; source .script.src debug',
        'Summit Series': 'tftp get {0} {1} .script.xsf; run script .script.xsf',
        'ERS Series':    'configure network address {0} filename {1}',
    }

    if chainStr:
        warpBuffer_add(chainStr)
    if Family not in tftpCheck:
        exitError('Sourcing commands via TFTP only supported in family types: {}'.format(", ".join(list(tftpCheck.keys()))))

    # Determine whether switch can do TFTP
    if tftpCheck[Family] == True:
        tftpEnabled = True
    else:
        tftpEnabled = sendCLI_showRegex(tftpCheck[Family])
    if not tftpEnabled:
        if Sanity:
            print "SANITY&gt; {}".format(tftpActivate[Family])
            ConfigHistory.append(tftpActivate[Family])
        else:
            sendCLI_configCommand(tftpActivate[Family], returnCliError, msgOnError) # Activate TFTP now
        warpBuffer_add(tftpDeactivate[Family])      # Restore TFTP state on completion

    if Sanity:
        for cmd in WarpBuffer:
            print "SANITY(warp)&gt; {}".format(cmd)
            ConfigHistory.append(cmd)
        LastError = None
        return True

    # Write the commands to a file under XMC's TFTP root directory
    tftpFileName = userName + '.' + scriptName() + '.' + switchIP.replace('.', '_')
    tftpFilePath = xmcTftpRoot + '/' + tftpFileName
    try:
        with open(tftpFilePath, 'w') as f:
            if Family == 'VSP Series': # Always add these 2 lines, as VSP source command does not inherit current context
                f.write("enable\n")
                f.write("config term\n")
            for cmd in WarpBuffer:
                f.write(cmd + "\n")
            f.write("\n") # Make sure we have an empty line at the end, or VSP sourcing won't process last line...
            debug("warpBuffer - write of TFTP config file : {}".format(tftpFilePath))
    except Exception as e: # Expect IOError
        print "{}: {}".format(type(e).__name__, str(e))
        exitError("Unable to write to TFTP file '{}'".format(tftpFilePath))

    # Make the switch fetch the file and execute it
    success = sendCLI_configChain(tftpExecute[Family].format(xmcServerIP, tftpFileName), returnCliError, msgOnError, waitForPrompt)
    # Clean up by deleting the file from XMC TFTP directory
    os.remove(tftpFilePath)
    debug("warpBuffer - delete of TFTP config file : {}".format(tftpFilePath))

    if not success: # In this case some commands might have executed, before the error; these won't be captured in ConfigHistory
        WarpBuffer = []
        return False
    ConfigHistory.extend(WarpBuffer)
    WarpBuffer = []
    LastError = None
    return True

def printConfigSummary(): # Print summary of all config commands executed with context indentation
    emc_cli.close()
    if not len(ConfigHistory):
        print "No configuration was performed"
        return
    print "The following configuration was successfully performed on switch:"
    indent = ''
    level = 0
    if Family in RegexContextPatterns:
        maxLevel = len(RegexContextPatterns[Family])
    for cmd in ConfigHistory:
        if Family in RegexContextPatterns:
            if RegexContextPatterns[Family][level].match(cmd):
                print "-&gt; {}{}".format(indent, cmd)
                if level + 1 &lt; maxLevel:
                    level += 1
                indent = ' ' * Indent * level
                continue
            elif RegexExitInstance.match(cmd):
                if level &gt; 0:
                    level -= 1
                indent = ' ' * Indent * level
        print "-&gt; {}{}".format(indent, cmd)

#
# XMC GraphQl NBI functions
#

def nbiQuery(jsonQuery, returnKey, debugKey=None, returnKeyError=False): # Makes a GraphQl query of XMC NBI; if returnKey provided returns that key value, else return whole response
    response = emc_nbi.query(jsonQuery)
    debug("nbiQuery response = {}".format(response))
    if 'errors' in response: # Query response contains errors
        if returnKeyError:
            return None
        abortError("nbiQuery for\n{}".format(jsonQuery), response['errors'][0].message)

    if returnKey: # If a specific key requested, we find it
        def recursionKeySearch(nestedDict):
            for key, value in nestedDict.iteritems():
                if key == returnKey:
                    return True, value
            for key, value in nestedDict.iteritems():
                if isinstance(value, (dict, LinkedHashMap)): # XMC Python is Jython where a dict is in fact a java.util.LinkedHashMap
                    foundKey, foundValue = recursionKeySearch(value)
                    if foundKey:
                        return True, foundValue
                return [None, None] # If we find nothing

        foundKey, returnValue = recursionKeySearch(response)
        if foundKey:
            if Debug:
                if debugKey: debug("{} = {}".format(debugKey, returnValue))
                else: debug("nbiQuery {} = {}".format(returnKey, returnValue))
            return returnValue
        if returnKeyError:
            return None
        # If requested key not found, raise error
        abortError("nbiQuery for\n{}".format(jsonQuery), 'Key "{}" was not found in query response'.format(returnKey))

    # Else, return the full response
    if Debug:
        if debugKey: debug("{} = {}".format(debugKey, response))
        else: debug("nbiQuery response = {}".format(response))
    return response

def nbiMutation(jsonQuery): # Makes a GraphQl mutation query of XMC NBI; returns true on success
    if Sanity:
        print "SANITY - NBI Mutation:\n{}\n".format(jsonQuery)
        LastError = None
        return True
    else:
        print "NBI Mutation Query:\n{}\n".format(jsonQuery)
    status = nbiQuery(jsonQuery, "status", "status", True)
    if status == "SUCCESS":
        return True
    else:
        return False

#
# IP address processing functions
#

def ipToNumber(dottedDecimalStr): # Method to convert an IP/Mask dotted decimal address into a long number; can also use for checking validity of IP addresses
    try: # bytearray ensures that IP bytes are valid (1-255)
        ipByte = list(bytearray([int(byte) for byte in dottedDecimalStr.split('.')]))
    except:
        return None
    if len(ipByte) != 4:
        return None
    debug("ipByte = {}".format(ipByte))
    ipNumber = (ipByte[0]&lt;&lt;24) + (ipByte[1]&lt;&lt;16) + (ipByte[2]&lt;&lt;8) + ipByte[3]
    debug("dottedDecimalStr {} = ipNumber {}".format(dottedDecimalStr, hex(ipNumber)))
    return ipNumber

def numberToIp(ipNumber): # Method to convert a long number into an IP/Mask dotted decimal address
    dottedDecimalStr = '.'.join( [ str(ipNumber &gt;&gt; (i&lt;&lt;3) &amp; 0xFF) for i in range(4)[::-1] ] )
    debug("ipNumber {} = dottedDecimalStr {}".format(hex(ipNumber), dottedDecimalStr))
    return dottedDecimalStr

def maskToNumber(mask): # Method to convert a mask (dotted decimal or Cidr number) into a long number
    if isinstance(mask, int) or re.match(r'^\d+$', mask): # Mask as number
        if int(mask) &gt; 0 and int(mask) &lt;= 32:
            maskNumber = (2**32-1) ^ (2**(32-int(mask))-1)
        else:
            maskNumber = None
    else:
        maskNumber = ipToNumber(mask)
    if maskNumber:
        debug("maskNumber = {}".format(hex(maskNumber)))
    return maskNumber

def subnetMask(ip, mask): # Return the IP subnet and Mask in dotted decimal and cidr formats for the provided IP address and mask
    ipNumber = ipToNumber(ip)
    maskNumber = maskToNumber(mask)
    subnetNumber = ipNumber &amp; maskNumber
    ipSubnet = numberToIp(subnetNumber)
    ipDottedMask = numberToIp(maskNumber)
    ipCidrMask = bin(maskNumber).count('1')
    debug("ipSubnet = {} / ipDottedMask = {} / ipCidrMask = {}".format(ipSubnet, ipDottedMask, ipCidrMask))
    return ipSubnet, ipDottedMask, ipCidrMask

#
# Miscellaneous functions
#

def addXmcSyslogEvent(severity, message, ip=None): # Adds a syslog event to XMC (only needed for Scripts)
    severityHash = {'emerg': 0, 'alert': 1, 'crit': 2, 'err': 3, 'warning': 4, 'notice': 5, 'info': 6, 'debug': 7}
    severityLevel = severityHash[severity] if severity in severityHash else 6
    session = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, 0)
    session.connect(('127.0.0.1', 514))
    if ip:
        session.send("&lt;{}&gt; XMC Script {} / Device: {} / {}".format(severityLevel,scriptName(),ip,message))
    else:
        session.send("&lt;{}&gt; XMC Script {} / {}".format(severityLevel,scriptName(),ip,message))
    session.close()


#
# INIT: Init Debug &amp; Sanity flags based on input combos
#
try:
    if emc_vars['userInput_sanity'].lower() == 'enable':
        Sanity = True
    elif emc_vars['userInput_sanity'].lower() == 'disable':
        Sanity = False
except:
    pass
try:
    if emc_vars['userInput_debug'].lower() == 'enable':
        Debug = True
    elif emc_vars['userInput_debug'].lower() == 'disable':
        Debug = False
except:
    pass


# --&gt; Insert Ludo Threads library here if required &lt;--


# --&gt; XMC Python script actually starts here &lt;--


#
# Variables:
#

CLI_Dict = {
    'VSP Series': {
        'disable_more_paging'        : 'terminal more disable',
        'enable_context'             : 'enable',
        'config_context'             : 'config term',
        'get_mgmt_ip_mask'           : 'int://show mgmt ip||{}\/(\d\d?) ', # IP address
        'check_vrf_exists'           : 'bool://show ip vrf||^{} ', # VRF name
        'list_mgmt_interfaces'       : 'list://show mgmt interface||^\d +\S+ +([A-Z]+) ',
        'delete_mgmt_clip'           : 'no mgmt clip\ny',
        'delete_mgmt_vlan'           : 'no mgmt vlan\ny',
        'create_mgmt_clip'           : # VRF name, IP address
                                       '''
                                       mgmt clip vrf {0}
                                          ip address {1}/32
                                          enable
                                       exit
                                       ''',
    },
}


NBI_Query = { # GraphQl query / NBI_Query['key'].replace('&lt;IP&gt;', var)
    'nbiAccess': '''
        {
          administration {
            serverInfo {
              version
            }
          }
        }
    ''',
    'checkSwitchXmcDb': '''
        {
          network {
            device(ip:"&lt;IP&gt;") {
              id
            }
          }
        }
    ''',
    'getSitePath': '''
        {
          network {
            device(ip: "&lt;IP&gt;") {
              sitePath
            }
          }
        }
    ''',
    'getDeviceAdminProfile': '''
        {
          network {
            device(ip:"&lt;IP&gt;") {
              deviceData {
                profileName
              }
            }
          }
        }
    ''',
    'delete_device': '''
        mutation {
          network {
            deleteDevices(input:{
              removeData: true
              devices: {
                ipAddress:"&lt;IP&gt;"
              }
            }) {
              status
              message
            }
          }
        }
    ''',
    'checkSwitchNacConfig': '''
        {
          accessControl {
            switch(ipAddress: "&lt;IP&gt;") {
              ipAddress
            }
          }
        }
    ''',
    'accessControlDeleteSwitch': '''
        mutation {
          accessControl {
            deleteSwitch(input: {
              searchKey: "&lt;IP&gt;"
            }) {
              message
              status
            }
          }
        }
    ''',
    'create_device': '''
        mutation {
          network {
            createDevices(input:{
              devices: {
                ipAddress:"&lt;IP&gt;"
                siteLocation:"&lt;SITE&gt;"
                profileName:"&lt;PROFILE&gt;"
              }
            }) {
              status
              message
            }
          }
        }
    ''',
}


#
# Main:
#
def main():
    print "{} version {} on XMC version {}".format(scriptName(), __version__, emc_vars["serverVersion"])
    nbiAccess = nbiQuery(NBI_Query['nbiAccess'], 'version', None, True)
    if nbiAccess == None:
        exitError('This XMC Script requires access to the GraphQl North Bound Interface (NBI). Make sure that XMC is running with an Advanced license and that your user profile is authorized for Northbound API.')

    #
    # Obtain Info on switch and from XMC
    #
    setFamily() # Sets global Family variable
    currentIp = emc_vars["deviceIP"]
    newIp = emc_vars["userInput_ip"].strip()
    newVrf = emc_vars["userInput_vrf"].strip()

    print "Information provided by User:"
    print " - New CLIP IP = {}".format(newIp)
    print " - New CLIP VRF = {}".format(newVrf)

    # IP validation
    if not ipToNumber(newIp):
        exitError('Invalid VLAN IP address {}'.format(newIp))
    if newIp == currentIp:
        exitError('Given IP {} is already used to manange the switch'.format(newIp))

    # VRF validation
    if not newVrf:
        newVrf = 'GlobalRouter'

    # Check if given IP is already in XMC
    checkNewIpInXmc = nbiQuery(NBI_Query['checkSwitchXmcDb'].replace('&lt;IP&gt;', newIp), 'device')
    if checkNewIpInXmc:
        exitError("Given IP address {} is already in XMC's database".format(newIp))

    # Check if given IP is already out there
    response = os.system("ping -c 1 " + newIp)
    if response == 0:
        exitError("Given IP address {} is already on the network (replies to ping)".format(newIp))

    # Get the site path for device
    sitePath = nbiQuery(NBI_Query['getSitePath'].replace('&lt;IP&gt;', currentIp), 'sitePath')

    # Find the Admin Profile which was in use for this device
    adminProfile = nbiQuery(NBI_Query['getDeviceAdminProfile'].replace('&lt;IP&gt;', currentIp), 'profileName')

    # Disable more paging (generatePortList might issue a CLI command, so do this before)
    sendCLI_showCommand(CLI_Dict[Family]['disable_more_paging'])

    # Enter privExec
    sendCLI_showCommand(CLI_Dict[Family]['enable_context'])

    # Get the mask of the IP we are using now
    currentIpMask = sendCLI_showRegex(CLI_Dict[Family]['get_mgmt_ip_mask'].format(currentIp))
    if not currentIpMask:
        exitError("Cannot determine mask of existing IP {}".format(currentIp))

    # Compare subnets for same mask (when moving from mgmt vlan IP to clip IP, ensure the clip IP is not in vlan IP subnet)
    if subnetMask(currentIp, currentIpMask)[0] == subnetMask(newIp, currentIpMask)[0]:
        exitError("New IP {} seems to be in same subnet of existing IP {}".format(newIp, currentIp))

    # Verify VRF existence
    if newVrf != 'GlobalRouter':
        vrfExists = sendCLI_showRegex(CLI_Dict[Family]['check_vrf_exists'].format(newVrf))
        if not vrfExists:
            exitError("VRF {} does not exist on switch; cannot create a mgmt clip for non-existent VRF".format(newVrf))

    # Verify whether mgmt clip is already set
    mgmtIfList = sendCLI_showRegex(CLI_Dict[Family]['list_mgmt_interfaces'])

    # Enter Config context
    sendCLI_showCommand(CLI_Dict[Family]['config_context'])

    # Queue delete of existing mgmt clip
    if 'CLIP' in mgmtIfList:
        warpBuffer_add(CLI_Dict[Family]['delete_mgmt_clip'])

    # Queue creation of new mgmt clip
    warpBuffer_add(CLI_Dict[Family]['create_mgmt_clip'].format(newVrf, newIp))

    # Queue delete of existing mgmt vlan
    if 'VLAN' in mgmtIfList:
        warpBuffer_add(CLI_Dict[Family]['delete_mgmt_vlan'])

    # Execute queued buffer
    warpBuffer_execute(waitForPrompt=False)
    addXmcSyslogEvent('info', "Changed IP address to {}".format(newIp), currentIp)

    # Delete the old IP from XMC
    if not nbiMutation(NBI_Query['delete_device'].replace('&lt;IP&gt;', currentIp)):
        exitError("Failed to delete IP '{}' from XMC's database".format(currentIp))
    addXmcSyslogEvent('info', "Deleted device from XMC database", currentIp)

    # Check whether switch was added to AccessControl
    switchNacExists = nbiQuery(NBI_Query['checkSwitchNacConfig'].replace('&lt;IP&gt;', currentIp), 'switch')
    # Sample of what we should get back
    # "switch": {
    #         "ipAddress": "10.8.4.2"
    # }
    # Or we get None
    if switchNacExists:
        if not nbiMutation( # Add the switch to AccessControl
            NBI_Query['accessControlDeleteSwitch']
            .replace('&lt;IP&gt;', currentIp)
        ):
            exitError("Failed to delete existing switch IP '{}' in NAC Engine Group".format(ipAddress))
        addXmcSyslogEvent('info', "Deleted device from XMC Control", currentIp)

    # Create the new IP from XMC
    if not nbiMutation(
        NBI_Query['create_device']
        .replace('&lt;IP&gt;', newIp)
        .replace('&lt;SITE&gt;', sitePath)
        .replace('&lt;PROFILE&gt;', adminProfile)
    ):
        exitError("Failed to add new device IP '{}' to XMC Site '{}' with admin profile '{}'".format(newIp, sitePath, adminProfile))
    addXmcSyslogEvent('info', "Added device to XMC Site {}".format(sitePath), newIp)

    # Print summary of config performed
    printConfigSummary()
    print "Deleted IP '{}' from XMC's database".format(currentIp)
    if switchNacExists:
        print "Deleted IP '{}' in NAC Engine Group".format(currentIp)
    print "Added new device IP '{}' to XMC Site '{}' with admin profile '{}'".format(newIp, sitePath, adminProfile)

main()
</content>
    <creationDate>1615564687832</creationDate>
    <creator>root</creator>
    <defaultCategory></defaultCategory>
    <devicesRequired>true</devicesRequired>
    <encoded>true</encoded>
    <contexts>,Device,</contexts>
    <lastUpdateDate>1615589743853</lastUpdateDate>
    <lastUpdatedBy>root</lastUpdatedBy>
    <miscXMLData></miscXMLData>
    <nosIds>,nos-id-voss,</nosIds>
    <postprocessScript></postprocessScript>
    <rollbackScript></rollbackScript>
    <saveConfigOnExit>false</saveConfigOnExit>
    <scriptOwner></scriptOwner>
    <scriptTimeout>60</scriptTimeout>
    <scriptType>Python</scriptType>
    <supprotedGroups></supprotedGroups>
    <roles>,NetSight Administrator,</roles>
    <vendor></vendor>
    <version>0</version>
</script>

