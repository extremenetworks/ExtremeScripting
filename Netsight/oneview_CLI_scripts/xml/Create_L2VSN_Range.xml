<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<script name="Create L2VSN Range">
    <abortOnError>true</abortOnError>
    <auditLogEnabled></auditLogEnabled>
    <category>,Config,</category>
    <comments>Create L2VSN Range on VSP - v2.0</comments>
    <content>'''
This script is provided free of charge by Extreme. We hope such scripts are
helpful when used in conjunction with Extreme products and technology and can
be used as examples to modify and adapt for your ultimate requirements.
Extreme will not provide any official support for these scripts. If you do
have any questions or queries about any of these scripts you may post on
Extreme's community website "The Hub" (https://community.extremenetworks.com/)
under the scripting category.

ANY SCRIPTS PROVIDED BY EXTREME ARE HEREBY PROVIDED "AS IS", WITHOUT WARRANTY
OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL EXTREME OR ITS THIRD PARTY LICENSORS BE LIABLE FOR ANY CLAIM,
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE USE OR DISTRIBUTION OF SUCH
SCRIPTS.
'''
##########################################################
# Ludo Standard library; Version 2.14                    #
# Written by Ludovico Stevens, CSE Extreme Networks      #
##########################################################
Debug = False    # Enables debug messages
Sanity = False   # If enabled, config commands are not sent to host (show commands are operational)

##########################################################
try:
    emc_vars
    execution = 'xmc'
except: # If not running on XMC Jython...
    # These lines only needed to run XMC Python script locally
    # They can also be pasted to XMC, but will not execute
    import sys
    import json
    import java.util
    import emc_cli      # Own local replica
    import emc_nbi      # Own local replica
    import emc_results  # Own local replica
    execution = 'dev'
    if len(sys.argv) &gt; 1: # Json file as 1st argv
        emc_vars = json.load(open(sys.argv[1]))
    else:
        emc_vars = json.load(open('emc_vars.json'))
##########################################################

#
# IMPORTS:
#
import re
import subprocess
from java.util import LinkedHashMap

#
# VARIABLES:
#
RegexPrompt = re.compile('.*[\?\$%#&gt;]\s?$')
RegexError  = re.compile(
    '^%|\x07|error|invalid|cannot|unable|bad|not found|not exist|not allowed|no such|out of range|incomplete|failed|denied|can\'t|ambiguous|do not|unrecognized',
    re.IGNORECASE
)
RegexPort = re.compile('^(?:[1-9]\d{0,2}[/:])?\d+$')
RegexPortRange = re.compile('^(?:([1-9]\d{0,2})([/:]))?(\d+)-(?:([1-9]\d{0,2})[/:])?(\d+)$')
RegexStarRange = re.compile('^([1-9]\d{0,2})(:)\*$') # XOS only
RegexContextPatterns = { # Ported from acli.pl
    'ERS Series' : [
        re.compile('^(?:interface |router \w+$|route-map (?:\"[\w\d\s\.\+-]+\"|[\w\d\.-]+) \d+$|ip igmp profile \d+$|wireless|application|ipv6 dhcp guard policy |ipv6 nd raguard policy )'), # level0
        re.compile('^(?:security|crypto|ap-profile |captive-portal |network-profile |radio-profile )'), # level1
        re.compile('^(?:locale)'), # level2
    ],
    'VSP Series' : [
        re.compile('^ *(?:interface |router \w+$|router vrf|route-map (?:\"[\w\d\s\.\+-]+\"|[\w\d\.-]+) \d+$|application|i-sid \d+|wireless|logical-intf isis \d+|mgmt [\dcvo]|ovsdb$)'), # level0
        re.compile('^ *(?:route-map (?:\"[\w\d\s\.\+-]+\"|[\w\d\.-]+) \d+$)'), # level1
    ],
}
RegexExitInstance = re.compile('^ *(?:exit|back|end)(?:\s|$)')
Indent = 3 # Number of space characters for each indentation
LastError = None
ConfigHistory = []
RollbackStack = []
SlotPortRange = None # Gets set to dict by getSlotPortRanges()
FamilyChildren = { # Children will be rolled into parent family for these scripts
    'Extreme Access Series': 'VSP Series',
}
Family = None # This needs to get set by setFamily()

#
# FUNCTIONS:
#
def debug(debugOutput): # Use function to include debugging in script; set above Debug variable to True or False to turn on or off debugging
    if Debug:
        print debugOutput

def setFamily(): # Set global Family variable; automatically handles family children, as far as this script is concerned
    global Family
    if emc_vars["family"] in FamilyChildren:
        Family = FamilyChildren[emc_vars["family"]]
    else:
        Family = emc_vars["family"]
    print "Using family type '{}' for this script".format(Family)
    if not Family in CLI_Dict:
        raise RuntimeError('This scripts only supports family types: {}'.format(", ".join(list(CLI_Dict.keys()))))

def portValue(port): # Function to pass to sorted(key) to sort port lists
    slotPort = re.split('[/:]', port)
    if len(slotPort) == 2: # slot/port format
        idx = int(slotPort[0])*100 + int(slotPort[1])
    else: # standalone port (no slot)
        idx = int(slotPort[0])
    return idx

def cleanOutput(outputStr): # Remove echoed command and final prompt from output
    lastLine = outputStr.splitlines()[-1:][0]
    if RegexPrompt.match(lastLine):
        lines = outputStr.splitlines()[1:-1]
    else:
        lines = outputStr.splitlines()[1:]
    return '\n'.join(lines)

def configChain(chainStr): # Produces a list of a set of concatenated commands (either with ';' or newlines)
    chainStr = re.sub(r'\n(\w)(\n|\s*;|$)', chr(0) + r'\1\2', chainStr) # Mask trailing "\ny" or "\nn" on commands before making list
    cmdList = map(str.strip, re.split(r'[;\n]', chainStr))
    cmdList = filter(None, cmdList) # Filter out empty lines, if any
    cmdList = [re.sub(r'\x00(\w)(\n|$)', r'\n\1\2', x) for x in cmdList] # Unmask after list made
    return cmdList

def parseRegexInput(cmdRegexStr): # Parses input command regex for both sendCLI_showRegex() and xmcLinuxCommand()
    if re.match(r'\w+(?:-\w+)?://', cmdRegexStr):
        mode, cmdRegexStr = map(str.strip, cmdRegexStr.split('://', 1))
    else:
        mode = None
    cmd, regex = map(str.strip, cmdRegexStr.split('||', 1))
    cmdList = map(str.strip, cmd.split('&amp;'))
    return mode, cmdList, regex

def formatOutputData(data, mode): # Formats output data for both sendCLI_showRegex() and xmcLinuxCommand()
    if not mode                 : value = data                                   # Legacy behaviour same as list
    elif mode == 'bool'         : value = bool(data)                             # No regex capturing brackets required
    elif mode == 'str'          : value = str(data[0]) if data else None         # Regex should have 1 capturing bracket at most
    elif mode == 'str-lower'    : value = str(data[0]).lower() if data else None # Same as str but string made all lowercase
    elif mode == 'str-upper'    : value = str(data[0]).upper() if data else None # Same as str but string made all uppercase
    elif mode == 'int'          : value = int(data[0]) if data else None         # Regex must have 1 capturing bracket at most
    elif mode == 'list'         : value = data                                   # If &gt; 1 capturing brackets, will be list of tuples
    elif mode == 'list-reverse' : value = list(reversed(data))                   # Same as list but in reverse order
    elif mode == 'list-diagonal': value = [data[x][x] for x in range(len(data))] # Regex pat1|pat2 = list of tuples; want [0][0],[1][1],etc
    elif mode == 'tuple'        : value = data[0] if data else ()                # Regex &gt; 1 capturing brackets, returns 1st tuple
    elif mode == 'dict'         : value = dict(data)                             # Regex must have 2 capturing brackets exactly
    elif mode == 'dict-reverse' : value = dict(map(reversed, data))              # Same as dict, but key/values will be flipped
    elif mode == 'dict-both'    : value = dict(data), dict(map(reversed, data))  # Returns 2 dict: dict + dict-reverse
    elif mode == 'dict-diagonal': value = dict((data[x][x*2],data[x][x*2+1]) for x in range(len(data))) # {[0][0]:[0][1], [1][2]:[1][3], etc}
    else:
        RuntimeError("sendCLI_showRegex: invalid scheme type '{}'".format(mode))
    return value

def abortError(cmd, errorOutput): # A CLI command failed, before bombing out send any rollback commands which may have been set
    print "Aborting script due to error on previous command"
    rollbackStack()
    print "Aborting because this command failed: {}".format(cmd)
    raise RuntimeError(errorOutput)

def rollbackStack(): # Execute all commands on the rollback stack
    if RollbackStack:
        print "Applying rollback commands to undo partial config and return device to initial state"
        while RollbackStack:
            sendCLI_configChain(RollbackStack.pop(), True)

def rollbackCommand(cmd): # Add a command to the rollback stack; these commands will get popped and executed should we need to abort
    RollbackStack.append(cmd)
    cmdList = map(str.strip, re.split(r'[;\n]', cmd)) # cmd could be a configChain
    cmdList = [x for x in cmdList if x] # Weed out empty elements 
    cmdOneLiner = " / ".join(cmdList)
    print "Pushing onto rollback stack: {}\n".format(cmdOneLiner)

def rollBackPop(number=0): # Remove entries from RollbackStack
    global RollbackStack
    if number == 0:
        RollbackStack = []
        print "Rollback stack emptied"
    else:
        del RollbackStack[-number:]
        print "Rollback stack popped last {} entries".format(number)

def sendCLI_showCommand(cmd, returnCliError=False, msgOnError=None): # Send a CLI show command; return output
    global LastError
    resultObj = emc_cli.send(cmd)
    if resultObj.isSuccess():
        outputStr = cleanOutput(resultObj.getOutput())
        if outputStr and RegexError.search("\n".join(outputStr.split("\n")[:4])): # If there is output, check for error in 1st 4 lines only (timestamp banner might shift it by 3 lines)
            if returnCliError: # If we asked to return upon CLI error, then the error message will be held in LastError
                LastError = outputStr
                if msgOnError:
                    print "==&gt; Ignoring above error: {}\n\n".format(msgOnError)
                return None
            abortError(cmd, outputStr)
        LastError = None
        return outputStr
    else:
        raise RuntimeError(resultObj.getError())

def sendCLI_configCommand(cmd, returnCliError=False, msgOnError=None): # Send a CLI config command
    global LastError
    cmdStore = re.sub(r'\n.+$', '', cmd) # Strip added CR+y or similar
    if Sanity:
        print "SANITY&gt; {}".format(cmd)
        ConfigHistory.append(cmdStore)
        LastError = None
        return True
    resultObj = emc_cli.send(cmd)
    if resultObj.isSuccess():
        outputStr = cleanOutput(resultObj.getOutput())
        if outputStr and RegexError.search("\n".join(outputStr.split("\n")[:2])): # If there is output, check for error in 1st 2 lines only
            if returnCliError: # If we asked to return upon CLI error, then the error message will be held in LastError
                LastError = outputStr
                if msgOnError:
                    print "==&gt; Ignoring above error: {}\n\n".format(msgOnError)
                return False
            abortError(cmd, outputStr)
        ConfigHistory.append(cmdStore)
        LastError = None
        return True
    else:
        raise RuntimeError(resultObj.getError())

def sendCLI_configChain(chainStr, returnCliError=False, msgOnError=None): # Send a semi-colon separated list of config commands
    cmdList = configChain(chainStr)
    for cmd in cmdList:
        success = sendCLI_configCommand(cmd, returnCliError, msgOnError)
        if not success:
            return False
    return True

def appendConfigDotCfg(chainStr): # Appends config commands to config.cfg (before 'end' statement) to be executed after reboot
    if Family != 'VSP Series':
        raise RuntimeError('appendConfigDotCfg(): only supported with "VSP Series" family type')
    cmdList = configChain(chainStr)
    if Sanity:
        for cmd in cmdList:
            print "SANITY(appended to config.cfg)&gt; {}".format(cmd)
        ConfigHistory.append('[after reboot] ' + cmd)
        LastError = None
        return True
    # Edit config.cfg
    cmdStream = "edit config.cfg\n?end\nO" # Edit config, find 'end' from bottom of file, insert text above
    for cmd in cmdList:
        cmdStream += cmd + "\n"
    cmdStream += "\x1bZZ" # Escape edit mode and save file
    debug("appendConfigDotCfg() - cmdStream:\n{}".format(cmdStream))
    resultObj = emc_cli.send(cmdStream)
    if resultObj.isSuccess():
        outputStr = cleanOutput(resultObj.getOutput())
        if outputStr and RegexError.search("\n".join(outputStr.split("\n")[:2])): # If there is output, check for error in 1st 2 lines only
            abortError(cmd, outputStr)
        else:
            for cmd in cmdList:
                print "Added to config.cfg: {}".format(cmd)
                ConfigHistory.append('[after reboot] ' + cmd)
            LastError = None
            return True
    else:
        raise RuntimeError(resultObj.getError())

def sendCLI_showRegex(cmdRegexStr, debugKey=None, returnCliError=False, msgOnError=None): # Send show command and extract values from output using regex
    # cmdRegexStr format: &lt;type&gt;://&lt;cli-show-command&gt;||&lt;regex-with-capturing-brackets&gt;
    # Regex is by default case-sensitive; for case-insensitive include (?i) at beginning of regex on input string
    mode, cmdList, regex = parseRegexInput(cmdRegexStr)
    for cmd in cmdList:
        # If cmdList we try each command in turn until one works; we don't want to bomb out on cmds before the last one in the list
        ignoreCliError = True if len(cmdList) &gt; 1 and cmd != cmdList[-1] else returnCliError
        outputStr = sendCLI_showCommand(cmd, ignoreCliError, msgOnError)
        if outputStr:
            break
    if not outputStr: # returnCliError true
        return None
    data = re.findall(regex, outputStr, re.MULTILINE)
    debug("sendCLI_showRegex() raw data = {}".format(data))
    # Format we return data in depends on what '&lt;type&gt;://' was pre-pended to the cmd &amp; regex
    value = formatOutputData(data, mode)
    if Debug:
        if debugKey: debug("{} = {}".format(debugKey, value))
        else: debug("sendCLI_showRegex OUT = {}".format(value))
    return value

def nbiQuery(jsonQuery, returnKey, debugKey=None, returnKeyError=False): # Makes a GraphQl query of XMC NBI; if returnKey provided returns that key value, else return whole response
    response = emc_nbi.query(jsonQuery)
    if 'errors' in response: # Query response contains errors
        if returnKeyError:
            return None
        abortError("nbiQuery for\n{}".format(jsonQuery), response['errors'][0].message)

    if returnKey: # If a specific key requested, we find it
        def recursionKeySearch(nestedDict):
            for key, value in nestedDict.iteritems():
                if key == returnKey:
                    return True, value
            for key, value in nestedDict.iteritems():
                if isinstance(value, (dict, LinkedHashMap)): # XMC Python is Jython where a dict is in fact a java.util.LinkedHashMap
                    foundKey, foundValue = recursionKeySearch(value)
                    if foundKey:
                        return True, foundValue
                return [None, None] # If we find nothing

        foundKey, returnValue = recursionKeySearch(response)
        if foundKey:
            if Debug:
                if debugKey: debug("{} = {}".format(debugKey, returnValue))
                else: debug("nbiQuery {} = {}".format(returnKey, returnValue))
            return returnValue
        if returnKeyError:
            return None
        # If requested key not found, raise error
        abortError("nbiQuery for\n{}".format(jsonQuery), 'Key "{}" was not found in query response'.format(returnKey))

    # Else, return the full response
    if Debug:
        if debugKey: debug("{} = {}".format(debugKey, response))
        else: debug("nbiQuery response = {}".format(response))
    return response

def nbiMutation(jsonQuery): # Makes a GraphQl mutation query of XMC NBI; returns true on success
    status = nbiQuery(jsonQuery, "status", "status", True)
    if status == "SUCCESS":
        return True
    else:
        return False

def xmcLinuxCommand(cmdRegexStr, debugKey=None): # Execute a command on XMC and recover the output
    mode, cmdList, regex = parseRegexInput(cmdRegexStr)
    cmd = cmdList[0] # We only support single shell command syntax for now
    cmdList = cmd.split(' ')
    if execution == 'dev': # I develop on my Windows laptop...
        cmdList[0] += '.bat'
    debug("xmcLinuxCommand about to execute : {}".format(cmd))
    try:
        outputStr = subprocess.check_output(cmdList)
    except Exception as e: # Expect OSError
        print "{}: {}".format(type(e).__name__, str(e))
        print "Error executing '{}' on XMC shell".format(cmd)
        return
    data = re.findall(regex, outputStr, re.MULTILINE)
    # Format we return data in depends on what '&lt;type&gt;://' was pre-pended to the cmd &amp; regex
    value = formatOutputData(data, mode)
    if Debug:
        if debugKey: debug("{} = {}".format(debugKey, value))
        else: debug("xmcLinuxCommand OUT = {}".format(value))
    return value

def getSlotPortRanges(): # Populates the SlotPortRange dict
    global SlotPortRange
    slotCommand = {'Summit Series': 'dict://show slot||^Slot-(\d+) +\S+ +\S+ +\S+ +(\d+)'} # Only XOS supported
    if Family not in slotCommand:
        SlotPortRange = {}
        return
    SlotPortRange = sendCLI_showRegex(slotCommand[Family])
    debug("getSlotPortRanges = {}".format(SlotPortRange))

def generatePortList(portStr, debugKey=None): # Given a port list/range, validates it and returns an ordered port list with no duplicates (can also be used for VLAN-id ranges)
    # This version of this function will not handle port ranges which span slots; also does not handle VSP channelized ports
    debug("generatePortList IN = {}".format(portStr))
    portDict = {} # Use a dict, will ensure no port duplicate keys
    for port in portStr.split(','):
        port = re.sub(r'^[\s\(]+', '', port) # Remove leading spaces  [ or '(' ]
        port = re.sub(r'[\s\)]+$', '', port) # Remove trailing spaces [ or ')' =&gt; XMC bug on ERS standalone units]
        if not len(port): # Skip empty string
            continue
        rangeMatch = RegexPortRange.match(port)
        starMatch = RegexStarRange.match(port)
        if rangeMatch: # We have a range of ports
            startSlot = rangeMatch.group(1)
            separator = rangeMatch.group(2)
            startPort = int(rangeMatch.group(3))
            endSlot = rangeMatch.group(4)
            endPort = int(rangeMatch.group(5))
            if endSlot and startSlot != endSlot:
                print "ERROR! generatePortList no support for ranges spanning slots: {}".format(port)
            elif startPort &gt;= endPort:
                print "ERROR! generatePortList invalid range: {}".format(port)
            else: # WE are good
                for portCount in range(startPort, endPort + 1):
                    if startSlot: # slot-based range
                        portDict[startSlot + separator + str(portCount)] = 1
                    else: # simple port range (no slot info)
                        portDict[str(portCount)] = 1
        elif starMatch: # We have a slot/* range
            slot = starMatch.group(1)
            separator = starMatch.group(2)
            if SlotPortRange == None: # Structure not populated
                getSlotPortRanges()
            if SlotPortRange:
                if slot in SlotPortRange:
                    for portCount in range(1, int(SlotPortRange[slot]) + 1):
                        portDict[slot + separator + str(portCount)] = 1
                else:
                    print "Warning: no range for slot {}; skipping: {}".format(slot, port)
            else:
                print "Warning: generatePortList skipping star range as not supported on this switch type: {}".format(port)
        elif RegexPort.match(port): # Port is in valid format
            portDict[port] = 1
        else: # Port is in an invalid format; don't add to dict, print an error message, don't raise exception 
            print "Warning: generatePortList skipping unexpected port format: {}".format(port)

    # Sort and return the list as a comma separated string
    portList = sorted(portDict, key=portValue)

    if Debug:
        if debugKey: debug("{} = {}".format(debugKey, portList))
        else: debug("generatePortList OUT = {}".format(portList))
    return portList

def generatePortRange(portList, debugKey=None): # Given a list of ports, generates a compacted port list/range string for use on CLI commands
    # Ported from acli.pl; this version of this function only compacts ranges within same slot, and does not support VSP channelized ports
    debug("generatePortRange IN = {}".format(portList))
    rangeMode = {'VSP Series': 2, 'ERS Series': 1, 'Summit Series': 1}
    elementList = []
    elementBuild = None
    currentType = None
    currentSlot = None
    currentPort = None
    rangeLast = None

    # First off, sort the list
    portList = sorted(portList, key=portValue)
    for port in portList:
        slotPort = re.split("([/:])", port) # Split on '/' (ERS/VSP) or ':'(XOS)
        # slotPort[0] = slot / slotPort[1] = separator ('/' or ':') / slotPort[2] = port
        if len(slotPort) == 3: # slot/port
            if elementBuild:
                if currentType == 's/p' and slotPort[0] == currentSlot and slotPort[2] == str(int(currentPort)+1):
                    currentPort = slotPort[2]
                    if rangeMode[Family] == 1:
                        rangeLast = currentPort
                    else: # rangeMode = 2
                        rangeLast = currentSlot + slotPort[1] + currentPort
                    continue
                else: # Range complete
                    if rangeLast:
                        elementBuild += '-' + rangeLast
                    elementList.append(elementBuild)
                    elementBuild = None
                    rangeLast = None
                    # Fall through below
            currentType = 's/p'
            currentSlot = slotPort[0]
            currentPort = slotPort[2]
            elementBuild = port

        if len(slotPort) == 1: # simple port (no slot)
            if elementBuild:
                if currentType == 'p' and port == str(int(currentPort)+1):
                    currentPort = port
                    rangeLast = currentPort
                    continue
                else: # Range complete
                    if rangeLast:
                        elementBuild += '-' + rangeLast
                    elementList.append(elementBuild)
                    elementBuild = None
                    rangeLast = None
                    # Fall through below
            currentType = 'p'
            currentPort = port
            elementBuild = port

    if elementBuild: # Close off last element we were holding
        if rangeLast:
            elementBuild += '-' + rangeLast
        elementList.append(elementBuild)

    portStr = ','.join(elementList)
    if Debug:
        if debugKey: debug("{} = {}".format(debugKey, portStr))
        else: debug("generatePortRange OUT = {}".format(portStr))
    return portStr                

def ipToNumber(dottedDecimalStr): # Method to convert an IP/Mask dotted decimal address into a long number; can also use for checking validity of IP addresses
    try: # bytearray ensures that IP bytes are valid (1-255)
        ipByte = list(bytearray([int(byte) for byte in dottedDecimalStr.split('.')]))
    except:
        return None
    if len(ipByte) != 4:
        return None
    debug("ipByte = {}".format(ipByte))
    ipNumber = (ipByte[0]&lt;&lt;24) + (ipByte[1]&lt;&lt;16) + (ipByte[2]&lt;&lt;8) + ipByte[3]
    debug("dottedDecimalStr {} = ipNumber {}".format(dottedDecimalStr, hex(ipNumber)))
    return ipNumber

def numberToIp(ipNumber): # Method to convert a long number into an IP/Mask dotted decimal address
    dottedDecimalStr = '.'.join( [ str(ipNumber &gt;&gt; (i&lt;&lt;3) &amp; 0xFF) for i in range(4)[::-1] ] )
    debug("ipNumber {} = dottedDecimalStr {}".format(hex(ipNumber), dottedDecimalStr))
    return dottedDecimalStr

def maskToNumber(mask): # Method to convert a mask (dotted decimal or Cidr number) into a long number
    if re.match(r'^\d+$', mask): # Mask as number
        if int(mask) &gt; 0 and int(mask) &lt;= 32:
            maskNumber = (2**32-1) ^ (2**(32-int(mask))-1)
        else:
            maskNumber = None
    else:
        maskNumber = ipToNumber(mask)
    if maskNumber:
        debug("maskNumber = {}".format(hex(maskNumber)))
    return maskNumber

def subnetMask(ip, mask): # Return the IP subnet and Mask in dotted decimal and cidr formats for the provided IP address and mask
    ipNumber = ipToNumber(ip)
    maskNumber = maskToNumber(mask)
    subnetNumber = ipNumber &amp; maskNumber
    ipSubnet = numberToIp(subnetNumber)
    ipDottedMask = numberToIp(maskNumber)
    ipCidrMask = bin(maskNumber).count('1')
    debug("ipSubnet = {} / ipDottedMask = {} / ipCidrMask = {}".format(ipSubnet, ipDottedMask, ipCidrMask))
    return ipSubnet, ipDottedMask, ipCidrMask

def ipGateway(ip, mask, gw): # Return the gateway IP address, as first or last IP in subnet, based on own IP/mask
    ipNumber = ipToNumber(ip)
    maskNumber = maskToNumber(mask)
    subnetNumber = ipNumber &amp; maskNumber
    if gw == 'first':
        gwNumber = subnetNumber + 1
        ip1numb = gwNumber + 1
        ip2numb = gwNumber + 2
    elif gw == 'last':
        gwNumber = subnetNumber + 2**(32-int(mask)) - 2
        ip1numb = gwNumber - 2
        ip2numb = gwNumber - 1
    else: # Error condition
        raise RuntimeError('ipGateway(): invalid gw type {}'.format(gw))
    debug("gwNumber = {} / ip1numb = {} / ip2numb = {}".format(hex(gwNumber), hex(ip1numb), hex(ip2numb)))
    gatewayIP = numberToIp(gwNumber)
    ip1 = numberToIp(ip1numb)
    ip2 = numberToIp(ip2numb)
    debug("gatewayIP = {} / ip1 = {} / ip2 = {}".format(gatewayIP, ip1, ip2))
    return gatewayIP, ip1, ip2

def printConfigSummary(): # Print summary of all config commands executed with context indentation
    emc_cli.close()
    print "The following configuration was successfully performed on switch:"
    indent = ''
    level = 0
    if Family in RegexContextPatterns:
        maxLevel = len(RegexContextPatterns[Family])
    for cmd in ConfigHistory:
        if Family in RegexContextPatterns:
            if RegexContextPatterns[Family][level].match(cmd):
                print "-&gt; {}{}".format(indent, cmd)
                if level + 1 &lt; maxLevel:
                    level += 1
                indent = ' ' * Indent * level
                continue
            elif RegexExitInstance.match(cmd):
                if level &gt; 0:
                    level -= 1
                indent = ' ' * Indent * level
        print "-&gt; {}{}".format(indent, cmd)


#
# INIT: Init code
#
try:
    if emc_vars['userInput_sanity'] == 'Enable':
        Sanity = True
    elif emc_vars['userInput_sanity'] == 'Disable':
        Sanity = False
except:
    pass
try:
    if emc_vars['userInput_debug'] == 'Enable':
        Debug = True
    elif emc_vars['userInput_debug'] == 'Disable':
        Debug = False
except:
    pass


# --&gt; Insert Ludo Threads library here if required &lt;--


# --&gt; XMC Python script actually starts here &lt;--

############################################################
# XMC Script: Create L2VSN Range (for device context menu) #
# Written by Ludovico Stevens, CSE Extreme Networks        #
############################################################
# Create multiple L2VSNs using VLAN list/ranges on VOSS
# Written by Ludovico Stevens, CSE Extreme Networks

__version__ = '2.0'

# 1.4 - Changed CLI dict 'get_isid_uni_data' so that it can work on VSP8600 also (no CLI grep)
#     - Updated libraries
#     - If input MLT ids provided would try and flex-uni enable all MLTs on switch
# 2.0 - Added ability to enter ports from XMC graphical port chooser
#     - MLT ids can still be entered, but now has logic to derive MLT-id from port list entered
#     - Script now allows untag bindings and follows same logic deriving I-SID from VLAN + offset

#
# XMC Metadata
#
'''
#@MetaDataStart
#@DetailDescriptionStart
######################################################################################
#
# This script provisions a range of L2VSNs on Fabric Connect VSPs using Switched-UNI
#
# An I-SID range/offset must be provided.
#
# A VLAN-id (or list of or range of or both combined) must also be provided, either
# at the global level or at the device level (when a value is provided at both global
# and device level, the device level value will be used).
#
# This script allows user to select the desired ports either using XMC's graphical
# port chooser or by entering port numbers/ranges in text input fields.
# XMC's graphical port chooser offers the ability to launch this script directly
# against port groups defined in XMC, without the user having to manually select the
# desired ports. Whereas the port text input offers a faster way to select many ports
# by entering port list/ranges as is done on the CLI.
# The script also offers the ability to select MLT ids to attach to services, though
# note that it is not necessary to enter the MLT id. One can equally select the MLT
# ports (either in XMC's graphical port chooser or in the port input text box) and
# this script will work out whether the requested ports belong to an MLT or LACP LAG
# and the configuration will automatically get applied to the corresponding MLT id.
# If the user has a preference as to whether this script should request port input via
# XMC's graphical port chooser or via text input and whether it is desired to have MLT
# input text fields, he may simply comment out all respective lines in sections named:
# #### Port Selection in text field : START
# #### Port Selection in text field : END
# #### MLT id Selection in text field : START
# #### MLT id Selection in text field : END
# #### Port Selection in XMC graphical port chooser : START
# #### Port Selection in XMC graphical port chooser : END
# If port inputs are selected using both the XMC graphical port chooser and the text
# input box, the latter will override the former.
#
# Whichever way port/MLT inputs are provided, if they are provided, the VSN service
# will be terminated on the ports/MLTs.
# If MLT ids are provided as input, the script will expect to find the MLTs already
# created on the switch, i.e. this script will not create the MLTs, it will just
# configure a Switched-UNI end-point on them.
# If no Port list or MLT list is provided, the service will be created on the switch,
# but will not be configured on any interfaces (this can be required when configuring
# a L2VSN on an SMLT-BEB pair, where the end-point is single attached to only one of
# the VSPs SMLT-BEBs; the other SMLT-BEB will need to have the same service termination
# or it will not work properly)
#
# The default tagging mode is "tag" and in this mode the user may specify many VLAN-ids
# (using list or range input). For each VLAN id the I-SID will be obtained by adding
# the VLAN-id to the I-SID offset range and the VLAN-id will become the Switched-UNI
# endpoint c-vid as well.
# If tagging mode is set to "untag" then only 1 VLAN-id can be provided (either
# globally or at switch level). In this case the VLAN-id will only be used to derive
# the I-SID value but the Switched-UNI endpoint will be created as untagged.
#
#######################################################################################
#@DetailDescriptionEnd
# ( = &amp;#40;
# ) = &amp;#41;
# , = &amp;#44;
# &lt; = &amp;lt;
# &gt; = &amp;gt;

#@SectionStart (description = "Service Definition to create")
#    @VariableFieldLabel (
#        description = "L2 SERVICE Domain &amp;#40;I-SID offset applied to VLAN-ids&amp;#41;",
#        type = string,
#        required = yes,
#        readOnly = no,
#        validValues = [Range0: I-SIDs 2000000, Range1: I-SIDs 2010000, Range2: I-SIDs 2020000, Range3: I-SIDs 2030000, Range4: I-SIDs 2040000],
#        name = "userInput_l2domain",
#    )
#    @VariableFieldLabel (
#        description = "VLAN-id &amp;#40;list or range&amp;#41;&amp;#44; can be overridden below at device level",
#        type = string,
#        required = no,
#        readOnly = no,
#        name = "userInput_vlanGlobal",
#    )
#### Port Selection in text field : START
#    @VariableFieldLabel (
#        description = "Port list&amp;#44; can be overridden below at device level",
#        type = string,
#        required = no,
#        readOnly = no,
#        name = "userInput_portsGlobal",
#    )
#### Port Selection in text field : END
#### MLT id Selection in text field : START
#    @VariableFieldLabel (
#        description = "MLT id list&amp;#44; can be overridden below at device level",
#        type = string,
#        required = no,
#        readOnly = no,
#        name = "userInput_mltsGlobal",
#    )
#### MLT id Selection in text field : END
#    @VariableFieldLabel (
#        description = "Tagging mode&amp;#44; can be overridden below at device level",
#        type = string,
#        required = yes,
#        readOnly = no,
#        validValues = [tag,untag &amp;#40;requires selecting 1 VLAN-id only&amp;#41;],
#        name = "userInput_tagGlobal",
#        value = "tag"
#    )
#@SectionEnd

#@SectionStart (description = "Device level Port and VLAN assignment to overrides above global values")
#### Port Selection in text field : START
#    @VariableFieldLabel (
#        description = "Port&amp;#40;s&amp;#41;",
#        type = string,
#        required = no,
#        readOnly = no,
#        name = "userInput_ports",
#        scope = device
#    )
#### Port Selection in text field : END
#### MLT id Selection in text field : START
#    @VariableFieldLabel (
#        description = "MLT id&amp;#40;s&amp;#41;",
#        type = string,
#        required = no,
#        readOnly = no,
#        name = "userInput_mlts",
#        scope = device
#    )
#### MLT id Selection in text field : END
#    @VariableFieldLabel (
#        description = "VLAN&amp;#40;list&amp;#41;",
#        type = string,
#        required = no,
#        readOnly = no,
#        name = "userInput_vlan",
#        scope = device
#    )
#    @VariableFieldLabel (
#        description = "Tagging",
#        type = string,
#        required = no,
#        readOnly = no,
#        validValues = [tag,untag],
#        name = "userInput_tag",
#        scope = device
#    )
#@SectionEnd

#@SectionStart (description = "Sanity / Debug")
#    @VariableFieldLabel (
#        description = "Sanity: enable if you do not trust this script and wish to first see what it does. In sanity mode config commands are not executed",
#        type = string,
#        required = no,
#        validValues = [Enable, Disable],
#        name = "userInput_sanity",
#    )
#    @VariableFieldLabel (
#        description = "Debug: enable if you need to report a problem to the script author",
#        type = string,
#        required = no,
#        validValues = [Enable, Disable],
#        name = "userInput_debug",
#    )
#@SectionEnd
#@MetaDataEnd
'''

#
# Imports:
#


#
# Variables:
#
CLI_Dict = {
    'VSP Series': {
        'disable_more_paging'        : 'terminal more disable',
        'enable_context'             : 'enable',
        'config_context'             : 'config term',
        'exit_config_context'        : 'exit',
        'end_config'                 : 'end',
        'save_config'                : 'save config',
        'get_mlt_data'               : 'list://show mlt||^(?:(\d+) +\d+.+?(?:access|trunk) +(norm|smlt) +(?:norm|smlt) *(\S+)?|(\d+) +\d+ +(?:[\d\/]+|null) +(enable|disable)|(\d+) +\d+ +\S+ +\S+ +\S+ +\S+ +\S+ +(enable|disable))',
        'list_fa_interfaces'         : 'list://show fa interface||^(?:Mlt|Port)(\d+(?:/\d+(?:/\d+)?)?) +(enabled|disabled) +(\d+) +(\d+) +(enabled|disabled)',
        'get_lacp_port_data'         : 'list://show lacp actor-oper interface||^(\d+/\d+(?:/\d+)?) +(\d+) +\d+ +\d+ +(true|false)',
        'list_mlt_lacp_key'          : 'dict://show lacp interface mlt||^(\d+) +\d+ +\d+ +\S+ +\d+ +(\d+)',
        'get_isid_uni_data'          : 'show running-config module i-sid',
        'get_flex_uni'               : 'dict://show interfaces gigabitEthernet config {}||^(\d\/\d+) +\S+ +\S+ +\S+ +\S+ +\S+ +(Enable|Disable)', # Port
        'get_mlt_flex_uni'           : 'dict://show mlt||^(\d+) +\d+ +\S+ +\S+ +\S+ +\S+ +\S+ +(enable|disable)',
        'create_flex_uni'            : 'vlan members remove 1 {0}; interface gigabitEthernet {0}; flex-uni enable; no shutdown; exit', # Port
        'create_mlt_flex_uni'        : 'interface mlt {0}; flex-uni enable; exit', # MLT id
        'create_switched_isid'       : 'i-sid {0}', # {0} = i-sid
        'create_switched_uni'        : { # {0} = VLAN id; {1} = port-list
            'tag'                    : 'c-vid {0} port {1}',
            'untag'                  : 'untagged-traffic port {1}',
                                       },
        'create_mlt_switched_uni'    : { # {0} = VLAN id; {1} = MLT-id
            'tag'                    : 'c-vid {0} mlt {1}',
            'untag'                  : 'untagged-traffic mlt {1}',
                                       },
        'delete_switched_uni'        : { # {0} = i-sid; {1} = VLAN id; {2} = port-list
            'tag'                    : 'i-sid {0}; no c-vid {1} port {2}; exit',
            'untag'                  : 'i-sid {0}; no untagged-traffic port {2}; exit',
            'transparent'            : 'i-sid {0}; no port {2}; exit'
                                       },
        'delete_mlt_switched_uni'    : { # {0} = i-sid; {1} = VLAN id; {2} = MLT id
            'tag'                    : 'i-sid {0}; no c-vid {1} mlt {2}; exit',
            'untag'                  : 'i-sid {0}; no untagged-traffic mlt {2}; exit',
            'transparent'            : 'i-sid {0}; no mlt {2}; exit'
                                       },
    },
}


#
# Functions:
#

def extractMltAndPortData(mltInclude=[], portInclude=[]): # Extract MLT data (include = ['fa','lacp','vlacp']) / and Port data (include = ['fa','lacp','vlacp'])
    # Only supported for family = 'VSP Series'
    mltDict = {}
    portDict = {}
    mltData = sendCLI_showRegex(CLI_Dict[Family]['get_mlt_data'])
    if 'fa' in mltInclude or 'fa' in portInclude:
        faData = sendCLI_showRegex(CLI_Dict[Family]['list_fa_interfaces'])
        for tpl in faData:
            enableFlag = True if tpl[1] == 'enabled' else False
            faMgmt = tpl[3]+':'+tpl[2] if tpl[3] != '0' and tpl[2] != '0' else None
            faAuth = True if tpl[4] == 'enabled' else False
            portDict[tpl[0]] = {'fa': enableFlag, 'faAuth': faAuth, 'faMgmt': faMgmt, 'key': None, 'lacp': False, 'mlt': None, 'vlacp': False}
            # Keys of portDict might include MLT-ids; these would be deleted below
    if 'lacp' in mltInclude or 'lacp' in portInclude:
        lacpPortData = sendCLI_showRegex(CLI_Dict[Family]['get_lacp_port_data'])
        for tpl in lacpPortData:
            enableFlag = True if tpl[2] == 'true' else False
            if tpl[0] not in portDict:
                if enableFlag:
                    portDict[tpl[0]] = {'fa': None, 'faAuth': None, 'faMgmt': None, 'key': tpl[1], 'lacp': enableFlag, 'mlt': None, 'vlacp': False}
                continue
            portDict[tpl[0]]['key'] = tpl[1]
            portDict[tpl[0]]['lacp'] = enableFlag
    if 'lacp' in mltInclude:
        lacpMltKey = sendCLI_showRegex(CLI_Dict[Family]['list_mlt_lacp_key'])
    for tpl in mltData:
        if tpl[0]:
            mltDict[tpl[0]] = {'type': tpl[1], 'ports': tpl[2]}
        elif tpl[3]:
            mltDict[tpl[3]]['lacp'] = True if tpl[4] == 'enable' else False
        elif tpl[5]:
            mltDict[tpl[5]]['flex'] = True if tpl[6] == 'enable' else False
    for mltid in mltDict:
        for port in generatePortList(mltDict[mltid]['ports']):
            if port not in portDict:
                portDict[port] = {'fa': None, 'faAuth': None, 'faMgmt': None, 'key': None, 'lacp': False, 'mlt': None, 'vlacp': False}
            portDict[port]['mlt'] = mltid
    for mltid in mltDict:
        if mltid in portDict:
            if 'fa' in mltInclude:
                mltDict[mltid]['fa'] = portDict[mltid]['fa']
                mltDict[mltid]['faAuth'] = portDict[mltid]['faAuth']
                mltDict[mltid]['faMgmt'] = portDict[mltid]['faMgmt']
            del portDict[mltid] # We no longer need it
        elif 'fa' in mltInclude:
            mltDict[mltid]['fa'] = None
            mltDict[mltid]['faAuth'] = None
            mltDict[mltid]['faMgmt'] = None
    if 'vlacp' in portInclude:
        vlacpData = sendCLI_showRegex(CLI_Dict[Family]['list_vlacp_ports'].format('')) # All ports
    elif 'vlacp' in mltInclude:
        vlacpData = sendCLI_showRegex(CLI_Dict[Family]['list_vlacp_ports'].format(generatePortRange(portDict.keys()))) # Only MLT ports
    if 'vlacp' in mltInclude:
        for mltid in mltDict:
            mltDict[mltid]['vlacp'] = False
        for port in vlacpData:
            if vlacpData[port] == 'true' and port in portDict and portDict[port]['mlt']:
                mltDict[portDict[port]['mlt']]['vlacp'] = True
    if 'vlacp' in portInclude:
        for port in vlacpData:
            if vlacpData[port] == 'true':
                if port not in portDict:
                    portDict[port] = {'fa': None, 'faAuth': None, 'faMgmt': None, 'key': None, 'lacp': False, 'mlt': None, 'vlacp': True}
                else:
                    portDict[port]['vlacp'] = True
    if 'lacp' in mltInclude:
        for mltid in mltDict:
            mltDict[mltid]['key'] = None
        for mltid in lacpMltKey:
            mltDict[mltid]['key'] = lacpMltKey[mltid]
            matchingKeyPortList = [x for x in portDict if portDict[x]['key'] == lacpMltKey[mltid]]
            # This overwrites the ports, but at least we get in there all ports configured with matching LACP key (not just ports active in MLT LAG)
            mltDict[mltid]['ports'] = generatePortRange(matchingKeyPortList)

    debug("extractMltAndPortData() mltDict = {}".format(mltDict))
    debug("extractMltAndPortData() portDict = {}".format(portDict))
    # mltDict: will include info of all MLTs
    # {"id" {'fa': None|True|False, 'faAuth': True|False, 'faMgmt': "vlan:isid", 'flex': True|False, 'key': None|"key", 'lacp': True|False, 'ports': "port-range", 'type': "smlt|norm", 'vlacp': True|False}}
    # portDict: will include info of all ports which are either FA enabled or LACP enabled or assigned to an MLT (statically or via LACP) [so not all ports]
    # {"port": {'fa': None|True|False, 'faAuth': True|False, 'faMgmt': "vlan:isid", 'key':None|"key", 'lacp': True|False, 'mlt': None|"id", 'vlacp': True|False}}
    return mltDict, portDict


def getIsidUniStruct(): # Extract all switched-uni/transparent-uni I-SIDs and port data
    # Only supported for family = 'VSP Series'
    # the "show i-sid" command is too fiddly to scrape...
    # the "show interfaces gigabitEthernet i-sid" command does not show I-SIDs with no ports assigned...
    # so we use "show run module i-sid" instead...
    cliOutput = sendCLI_showCommand(CLI_Dict[Family]['get_isid_uni_data'])
    isidUniPortDict = {}
    foundIsidData = False
    for line in cliOutput.splitlines():
        matchObj = re.match(r'^i-sid (\d+) ', line)
        if matchObj:
            isid = matchObj.group(1)
            isidUniPortDict[isid] = {}
            foundIsidData = True
            continue

        if foundIsidData:
            matchObj = re.match(r'c-vid (\d+) (port|mlt) (\S+)', line)
            if matchObj:
                tagging = 'tag'
                cvlan = matchObj.group(1)
                btype = matchObj.group(2)
                if btype == 'port':
                    ports = matchObj.group(3)
                    mlt = None
                else:
                    ports = None
                    mlt = matchObj.group(3)
            else:
                matchObj = re.match(r'untagged-traffic (port|mlt) (\S+)', line)
                if matchObj:
                    tagging = 'untag'
                    cvlan = None
                    btype = matchObj.group(1)
                    if btype == 'port':
                        ports = matchObj.group(2)
                        mlt = None
                    else:
                        ports = None
                        mlt = matchObj.group(2)
                else:
                    matchObj = re.match(r'(port|mlt) (\S+)', line)
                    if matchObj:
                        tagging = 'transparent'
                        cvlan = None
                        btype = matchObj.group(1)
                        if btype == 'port':
                            ports = matchObj.group(2)
                            mlt = None
                        else:
                            ports = None
                            mlt = matchObj.group(2)
                    elif re.match(r'exit', line):
                        foundIsidData = False
                        continue
                    else:
                        continue

            if ports:
                portList = generatePortList(ports)
                debug("portList = {}".format(portList))
                for port in portList:
                    isidUniPortDict[isid][port] = {'type': tagging, 'vlan': cvlan}
            if mlt:
                isidUniPortDict[isid][mlt] = {'type': tagging, 'vlan': cvlan}

    debug("getIsidUniStruct OUT = {}".format(isidUniPortDict))
    return isidUniPortDict


def main():
    print "Create L2VSN Range version {}".format(__version__)
    setFamily() # Sets global Family variable
    enteredPortList = []

#### Port Selection in XMC graphical port chooser : START
    try:
        enteredPortList = generatePortList(emc_vars['port'])
        enteredPortRange = generatePortRange(enteredPortList)
    except:
        enteredPortRange = ''
    debug("enteredPortList = {}".format(enteredPortList))
#### Port Selection in XMC graphical port chooser : END

    l2domain  = emc_vars["userInput_l2domain"]
    try:
        vlanGb = emc_vars["userInput_vlanGlobal"].strip()
    except:
        vlanGb = None
    try:
        portsGb = emc_vars["userInput_portsGlobal"].strip()
    except:
        portsGb = None
    try:
        mltsGb = emc_vars["userInput_mltsGlobal"].strip()
    except:
        mltsGb = None
    try:
        taggingGb = emc_vars["userInput_tagGlobal"].split(' ', 1)[0]
    except:
        taggingGb = None
    try:
        vlanDv = emc_vars["userInput_vlan"].strip()
    except:
        vlanDv = None
    try:
        portsDv = emc_vars["userInput_ports"].strip()
    except:
        portsDv = None
    try:
        mltsDv = emc_vars["userInput_mlts"].strip()
    except:
        mltsDv = None
    try:
        taggingDv = emc_vars["userInput_tag"]
    except:
        taggingDv = None

    isidOffset = re.search(r'(\d+$)', l2domain).group(1)
    debug("isidOffset = {}".format(isidOffset))

    print "Information provided by User:"
    print " Global settings:"
    print " - L2 Domain = {}".format(l2domain)
    print " - I-SID offset = {}".format(isidOffset)
    print " - Global VLAN(s) = {}".format(vlanGb)
    print " - Global Ports GUI input = {}".format(enteredPortRange)
    print " - Global Ports text input = {}".format(portsGb)
    print " - Global MLT ids = {}".format(mltsGb)
    print " - Global Tagging mode = {}".format(taggingGb)
    print " Device override settings:"
    print " - VLAN(s) = {}".format(vlanDv)
    print " - Ports = {}".format(portsDv)
    print " - MLT ids = {}".format(mltsDv)
    print " - Tagging mode = {}".format(taggingDv)

    # Determine VLAN, Ports and tagging to use
    if taggingDv:
        tagging = taggingDv
    elif taggingGb:
        tagging = taggingGb
    else:
        tagging = 'tag'

    if vlanDv:
        vlan = vlanDv
    elif vlanGb:
        vlan = vlanGb
    else:
        raise RuntimeError('One or more VLANs must be provided')

    vlanList = generatePortList(vlan)
    debug("vlanList = {}".format(vlanList))
    for vlan in vlanList:
        if not vlan.isdigit() or int(vlan) &gt; 4095:
            raise RuntimeError('Invalid VLAN id value {}; needs to be a number not higher than 4059'.format(vlan))
    if tagging == 'untag' and len(vlanList) &gt; 1:
        raise RuntimeError('For untag binding only 1 VLAN-id must be provided')

    if portsDv:
        ports = portsDv
    elif portsGb:
        ports = portsGb
    else:
        ports = None

    if mltsDv:
        mlts = mltsDv
    elif mltsGb:
        mlts = mltsGb
    else:
        mlts = None
    if mlts:
        inputMltList = generatePortList(mlts)
    else:
        inputMltList = []
    debug("inputMltList = {}".format(inputMltList))
    for mlt in inputMltList:
        if not mlt.isdigit() or int(mlt) &gt; 512:
            raise RuntimeError('Invalid MLT id value {}; needs to be a number not higher than 512'.format(mlt))

    # Disable more paging (generatePortList might issue a CLI command, so do this before)
    sendCLI_showCommand(CLI_Dict[Family]['disable_more_paging'])

    # Obtain ports in list and range format
    if ports:
        inputPortList = generatePortList(ports)
        inputPortRange = generatePortRange(inputPortList)
    elif enteredPortList:
        inputPortList = enteredPortList
        inputPortRange = enteredPortRange
    else:
        inputPortList = []
        inputPortRange = ''
    debug("inputPortList = {}".format(inputPortList))
    debug("inputPortRange = {}".format(inputPortRange))

    # Enter privExec, for show commands
    sendCLI_showCommand(CLI_Dict[Family]['enable_context'])

    # Determine actual port list and MLT list to configure
    portList = []
    mltList = inputMltList
    if inputPortList: # Only if some ports were selected
        # Extract MLT &amp; port data; we also get FA interface data from here directly
        mltDict, portDict = extractMltAndPortData(['fa', 'lacp'], ['fa', 'lacp'])

        # Check if user entered MLT ids exist
        invalidMltList = [x for x in mltList if x not in mltDict]
        if invalidMltList:
            raise RuntimeError('The following MLT ids do not exist on the switch: {}'.format(generateRange(invalidMltList)))

        # Determine ports and MLT ids to configure
        for port in inputPortList:
            if port in portDict and portDict[port]['mlt']:
                if portDict[port]['mlt'] not in mltList:
                    mltList.append(portDict[port]['mlt'])
            else:
                portList.append(port)
        debug("portList = {}".format(portList))
        mltList = [str(x) for x in sorted([int(x) for x in mltList])] # Sort the MLT ids
        debug("mltList = {}".format(mltList))
        portRange = generatePortRange(portList)
        debug("portRange = {}".format(portRange))

        print "Extracted information from VSP switch via CLI:"
        if enteredPortList: # Only if some ports were selected
            print " - MLT ids to configure for service = {}".format(generatePortRange(mltList))
            print " - Individual ports to configure for service = {}".format(portRange)
            print

    # Enter config mode now
    sendCLI_configCommand(CLI_Dict[Family]['config_context'])
    performConfig = False # Assume not

    # Only Switched UNI config covered here
    uniIsidDict = getIsidUniStruct()
    debug('uniIsidDict = {}'.format(uniIsidDict))
    if portList:
        flexUniList = sendCLI_showRegex(CLI_Dict[Family]['get_flex_uni'].format(portRange), 'flexUniList')
        flexUniDisabledList = [x for x in flexUniList if flexUniList[x] == 'Disable']
        debug("flexUniDisabledList = {}".format(flexUniDisabledList))
        if flexUniDisabledList:
            flexUniEnablePortRange = generatePortRange(flexUniDisabledList)
            print "Selected ports where we need to enable flex-uni = {}".format(flexUniDisabledList)
            # Enable flex-uni on ports which are not already flex-uni enabled
            sendCLI_configChain(CLI_Dict[Family]['create_flex_uni'].format(flexUniEnablePortRange))
            performConfig = True

    if mltList:
        flexMltUniList = sendCLI_showRegex(CLI_Dict[Family]['get_mlt_flex_uni'], 'flexMltUniList')
        flexMltUniDisabledList = [x for x in flexMltUniList if x in mltList and flexMltUniList[x] == 'disable']
        debug("flexMltUniDisabledList = {}".format(flexMltUniDisabledList))
        if flexMltUniDisabledList:
            print "MLT ids where we need to enable flex-uni = {}".format(flexMltUniDisabledList)
            # Enable flex-uni on MLTs which are not already flex-uni enabled
            for mlt in flexMltUniDisabledList:
                sendCLI_configChain(CLI_Dict[Family]['create_mlt_flex_uni'].format(mlt))
            performConfig = True

    for vlan in vlanList:
        # Prepare the I-SID
        isid = str(int(isidOffset) + int(vlan))
        debug("vlan {} = isid {}".format(vlan, isid))
        portsToConfigure = []
        mltsToConfigure = []
        vlanMatch = vlan if tagging == 'tag' else None

        if portList:
            if isid in uniIsidDict:
                portsInIsidToRemove = [x for x in portList if x in uniIsidDict[isid] and uniIsidDict[isid][x]['vlan'] != vlanMatch]
                debug("portsInIsidToRemove = {}".format(portsInIsidToRemove))
                if portsInIsidToRemove:
                    print "Selected ports already configured in same I-SID {} but with wrong c-vid/tagging mode = {}".format(isid, portsInIsidToRemove)
                    for port in portsInIsidToRemove:
                        # Delete any of the selected ports which might happen to have already been configured in same I-SID but different c-vid
                        sendCLI_configChain(CLI_Dict[Family]['delete_switched_uni'][uniIsidDict[isid][port]['type']].format(isid, uniIsidDict[isid][port]['vlan'], port))

            # If one of the user selected ports happens to be already assigned to the I-SID and C-VID already, then we filter out these ports
            portsToConfigure = [x for x in portList if (isid not in uniIsidDict ) or ( x not in uniIsidDict[isid] ) or ( x in uniIsidDict[isid] and uniIsidDict[isid][x]['vlan'] != vlanMatch )]
            debug("portsToConfigure = {}".format(portsToConfigure))
            if portsToConfigure:
                portRange = generatePortRange(portsToConfigure)
                print "Effective ports we need to configure = {}".format(portRange)

        if mltList:
            if isid in uniIsidDict:
                mltsInIsidToRemove = [x for x in mltList if x in uniIsidDict[isid] and uniIsidDict[isid][x]['vlan'] != vlanMatch]
                debug("mltsInIsidToRemove = {}".format(mltsInIsidToRemove))
                if mltsInIsidToRemove:
                    print "MLTs selected already configured in same I-SID {} but with wrong c-vid/tagging mode = {}".format(isid, mltsInIsidToRemove)
                    for mlt in mltsInIsidToRemove:
                        # Delete any of the selected MLTs which might happen to have already been configured in same I-SID but different c-vid
                        sendCLI_configChain(CLI_Dict[Family]['delete_mlt_switched_uni'][uniIsidDict[isid][mlt]['type']].format(isid, uniIsidDict[isid][mlt]['vlan'], mlt))

            # If one of the user selected MLTs happens to be already assigned to the I-SID and C-VID already, then we filter out these MLTs
            mltsToConfigure = [x for x in mltList if (isid not in uniIsidDict ) or ( x not in uniIsidDict[isid] ) or ( x in uniIsidDict[isid] and uniIsidDict[isid][x]['vlan'] != vlanMatch )]
            debug("mltsToConfigure = {}".format(mltsToConfigure))
            if mltsToConfigure:
                print "Effective MLT ids we need to configure = {}".format(generatePortRange(mltsToConfigure))

        # Create/enter I-SID context
        if portsToConfigure or mltsToConfigure or isid not in uniIsidDict:
            sendCLI_configCommand(CLI_Dict[Family]['create_switched_isid'].format(isid))
            performConfig = True
        if portsToConfigure:
            # Assign ports to I-SID
            sendCLI_configCommand(CLI_Dict[Family]['create_switched_uni'][tagging].format(vlan, portRange))
        if mltsToConfigure:
            # Assign MLT ids to I-SID
            for mlt in mltsToConfigure:
                sendCLI_configCommand(CLI_Dict[Family]['create_mlt_switched_uni'][tagging].format(vlan, mlt))
        # Exit I-SID context
        if performConfig:
            sendCLI_configCommand(CLI_Dict[Family]['exit_config_context'])


    # End and save config
    if 'end_config' in CLI_Dict[Family]:
        sendCLI_configCommand(CLI_Dict[Family]['end_config'])
    if performConfig:
        sendCLI_configCommand(CLI_Dict[Family]['save_config'])

    # Print summary of config performed
    printConfigSummary()

main()
</content>
    <creationDate>1562692330816</creationDate>
    <creator>lstevens</creator>
    <defaultCategory></defaultCategory>
    <devicesRequired>true</devicesRequired>
    <contexts>,Device,Groups,</contexts>
    <lastUpdateDate>1588418385550</lastUpdateDate>
    <lastUpdatedBy>lstevens</lastUpdatedBy>
    <miscXMLData></miscXMLData>
    <nosIds>,nos-id-voss,</nosIds>
    <postprocessScript></postprocessScript>
    <rollbackScript></rollbackScript>
    <saveConfigOnExit>false</saveConfigOnExit>
    <scriptOwner></scriptOwner>
    <scriptTimeout>60</scriptTimeout>
    <scriptType>Python</scriptType>
    <supprotedGroups></supprotedGroups>
    <roles>,NetSight Administrator,</roles>
    <vendor></vendor>
    <version>0</version>
</script>

